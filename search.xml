<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AC自动机再放送</title>
    <url>/AC-Zi-Dong-Ji/</url>
    <content><![CDATA[<h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><p>AC 自动机可以理解为在多个串上的 KMP，利用 Trie 树来维护这些串，nxt 数组变为 fail 指针。</p>
<p>fail 指针的构造思想如下：</p>
<p>考虑 Trie 树中当前的节点 $u$，$u$ 的父节点是 $p$，$p$ 通过字符 $c$ 的边指向 $u$，即 $\text{trie}[p,c]=u$。假设深度小于 $u$ 的所有节点的 $\text{fail}$ 指针都已求得。</p>
<p>1.如果 $\text{trie}[\text{fail}[p],c]$ 存在，则让 $u$ 的 fail 指针指向 trie[fail[p], c]。相当于在 $p$ 和 $\text{fail}[p]$ 后面加一个字符 $c$，分别对应 $u$ 和 $\text{fail}[u]$。</p>
<p>2.如果 trie[fail[p], c] 不存在，那么我们继续找到 trie[fail[fail[p]], c]，重复 1 的判断过程，一直跳 fail 指针直到根节点。</p>
<p>3.如果真的没有，就让 fail 指针指向根节点。</p>
<p>可以发现，AC 自动机与 KMP 是非常相似的。</p>
<p>这是基本思想，具体实现我们可以直接<strong>构造 Trie 图</strong>以进行多串匹配。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="普通实现"><a href="#普通实现" class="headerlink" title="普通实现"></a>普通实现</h4><p><strong>【模板】AC自动机（简单版）(luoguP3808)</strong></p>
<p>给定 $n$ 个模式串 $s_i$ 和一个文本串 $t$，求有多少个不同的模式串在文本串里出现过，两个模式串不同当且仅当它们编号不同。</p>
<p>$1\le n\le10^6$，$1\le|t|\le10^6$，$1\le\sum_{i=1}^n|s_i|\le10^6$。</p>
<hr>
<p><strong>1 在 Trie 树上插入各串</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(tr[pos][tmp] == <span class="number">0</span>)</span><br><span class="line">            tr[pos][tmp] = ++ct;</span><br><span class="line">        pos = tr[pos][tmp];</span><br><span class="line">    &#125;</span><br><span class="line">    val[pos] ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2 fail指针的构建</strong></p>
<p>按照上面的思路进行构建</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(fail));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">0</span>][i])	<span class="comment">// 0 是根节点，后面 while(tmp &amp;&amp; ...) 其实前者是 tmp != rt</span></span><br><span class="line">            q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);	<span class="comment">// 从根节点的子节点开始，类似于 KMP 从 2 开始</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">empty</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line">            <span class="keyword">if</span>(tr[x][i]) &#123;	<span class="comment">// 匹配现在的</span></span><br><span class="line">                <span class="keyword">int</span> tmp = fail[x];</span><br><span class="line">                <span class="keyword">while</span>(tmp &amp;&amp; tr[tmp][i] == <span class="number">0</span>)	<span class="comment">// 没匹配上，往回跳</span></span><br><span class="line">                    tmp = fail[tmp];</span><br><span class="line">                <span class="keyword">if</span>(tr[tmp][i])	<span class="comment">// fail 指针那边的也有 i 这个字符，匹配上了</span></span><br><span class="line">                    tmp = tr[tmp][i];</span><br><span class="line">                fail[tr[x][i]] = tmp;</span><br><span class="line">                q.<span class="built_in">push</span>(tr[x][i]);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3 多模式匹配</strong></p>
<p>多个模式串对文本串的匹配。</p>
<p>如果能匹配，就匹配，不能匹配，就跳 fail，注意可能多次匹配，所以要去掉重复匹配的贡献。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos &amp;&amp; tr[pos][tmp] == <span class="number">0</span>)</span><br><span class="line">            pos = fail[pos];</span><br><span class="line">        <span class="keyword">if</span>(tr[pos][tmp])</span><br><span class="line">            pos = tr[pos][tmp];</span><br><span class="line">        ret += val[pos];</span><br><span class="line">        val[pos] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> ct, tr[N][<span class="number">26</span>], val[N], fail[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(tr[pos][tmp] == <span class="number">0</span>)</span><br><span class="line">            tr[pos][tmp] = ++ct;</span><br><span class="line">        pos = tr[pos][tmp];</span><br><span class="line">    &#125;</span><br><span class="line">    val[pos] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">0</span>][i]) &#123;</span><br><span class="line">            fail[tr[<span class="number">0</span>][i]] = <span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">empty</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line">            <span class="keyword">if</span>(tr[x][i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = fail[x];</span><br><span class="line">                <span class="keyword">while</span>(tmp &amp;&amp; tr[tmp][i] == <span class="number">0</span>)</span><br><span class="line">                    tmp = fail[tmp];</span><br><span class="line">                <span class="keyword">if</span>(tr[tmp][i])</span><br><span class="line">                    tmp = tr[tmp][i];</span><br><span class="line">                fail[tr[x][i]] = tmp;</span><br><span class="line">                q.<span class="built_in">push</span>(tr[x][i]);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos &amp;&amp; tr[pos][tmp] == <span class="number">0</span>)</span><br><span class="line">            pos = fail[pos];</span><br><span class="line">        <span class="keyword">if</span>(tr[pos][tmp])</span><br><span class="line">            pos = tr[pos][tmp];</span><br><span class="line">        ret += val[pos];</span><br><span class="line">        val[pos] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Insert</span>(s+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(s+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="Trie图的构建"><a href="#Trie图的构建" class="headerlink" title="Trie图的构建"></a>Trie图的构建</h4><p>建出真实的边，使 Trie 树变为一张图。</p>
<p>具体而言，只要把儿子记录上即可。</p>
<p>复杂度 $O(|S|\times n)$，$|S|$ 是字符集大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line">        <span class="keyword">if</span>(t[rt][i]) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(t[rt][i]);</span><br><span class="line">            fail[t[<span class="number">0</span>][i]] = rt;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">empty</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line">            <span class="keyword">if</span>(t[x][i]) &#123;</span><br><span class="line">                fail[t[x][i]] = t[fail[x]][i];</span><br><span class="line">                q.<span class="built_in">push</span>(t[x][i]);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                t[x][i] = t[fail[x]][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<p>对于 <code>else</code> 部分，相当于直接把这个不存在的儿子接到其失配指针的这个儿子，如果失配指针也没有这个儿子呢？那么它一定也通过 <code>else</code> 接上了可能的儿子，所以可以保证接上的恰好是一个最优的位置。</p>
<p>对于 <code>if</code> 部分，类似地，假如它的父亲（$x$）有 $i$ 这个儿子，相当于直接匹配，那么显然是对的，如果没有，等同于 <code>else</code> 部分的解释，它一定指向了一个最优的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        pos = tr[pos][tmp];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = pos; j &gt; <span class="number">0</span> &amp;&amp; val[j] != <span class="number">-1</span>; j = fail[j]) &#123;  <span class="comment">// 由于打标记后 j = fail[j] 仍然会进行下去，所以一直到根节点全都打了标记，所以如果再次走到这个位置可以直接退出</span></span><br><span class="line">            ret += val[j];</span><br><span class="line">            val[j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> ct, tr[N][<span class="number">26</span>], val[N], fail[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(tr[pos][tmp] == <span class="number">0</span>)</span><br><span class="line">            tr[pos][tmp] = ++ct;</span><br><span class="line">        pos = tr[pos][tmp];</span><br><span class="line">    &#125;</span><br><span class="line">    val[pos] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">0</span>][i])</span><br><span class="line">            q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">empty</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line">            <span class="keyword">if</span>(tr[x][i]) &#123;</span><br><span class="line">                fail[tr[x][i]] = tr[fail[x]][i];</span><br><span class="line">                q.<span class="built_in">push</span>(tr[x][i]);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                tr[x][i] = tr[fail[x]][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        pos = tr[pos][tmp];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = pos; j &gt; <span class="number">0</span> &amp;&amp; val[j] != <span class="number">-1</span>; j = fail[j]) &#123;  <span class="comment">// 由于打标记后 j = fail[j] 仍然会进行下去，所以一直到根节点全都打了标记，所以如果再次走到这个位置可以直接退出</span></span><br><span class="line">            ret += val[j];</span><br><span class="line">            val[j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Insert</span>(s+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(s+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>另外一个模板</strong></p>
<p><strong>【模板】AC自动机（加强版）(luoguP3796)</strong></p>
<p>有 $N$ 个由小写字母组成的模式串以及一个文本串 $T$，找出哪些模式串在文本串 $T$ 中出现的次数最多。</p>
<p>$1\le N\le 150$，单个模式串长度 $\le70$，文本串长度 $\le10^6$。</p>
<hr>
<p>由于 Trie 数每个节点表示的字符串具有唯一性，并且 AC 自动机每到达一个位置就表示和当前位置表示的字符串匹配了，我们可以这么做：</p>
<p>记录每个模式串结尾位置，匹配时每到一个位置就累加这个位置的模式串出现次数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20010</span>, M = <span class="number">1000010</span>, H = <span class="number">80</span>, P = <span class="number">160</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[M];</span><br><span class="line"><span class="keyword">char</span> str[P][H];</span><br><span class="line"><span class="keyword">int</span> ct, t[N][<span class="number">26</span>], fail[N], ed[N];</span><br><span class="line"><span class="keyword">int</span> tim[P]; <span class="comment">// 各个串的匹配次数</span></span><br><span class="line"><span class="keyword">int</span> top, stk[P], maxtim;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> rk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[pos][tmp] == <span class="number">0</span>)</span><br><span class="line">            t[pos][tmp] = ++ct;</span><br><span class="line">        pos = t[pos][tmp];</span><br><span class="line">    &#125;</span><br><span class="line">    ed[pos] = rk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line">        <span class="keyword">if</span>(t[<span class="number">0</span>][i])</span><br><span class="line">            q.<span class="built_in">push</span>(t[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">empty</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line">            <span class="keyword">if</span>(t[x][i]) &#123;</span><br><span class="line">                fail[t[x][i]] = t[fail[x]][i];</span><br><span class="line">                q.<span class="built_in">push</span>(t[x][i]);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                t[x][i] = t[fail[x]][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        pos = t[pos][tmp];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = pos; j; j = fail[j])</span><br><span class="line">            tim[ed[j]] ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str[i]+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Insert</span>(str[i]+<span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">query</span>(s+<span class="number">1</span>);</span><br><span class="line">    maxtim = <span class="number">0</span>;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">if</span>(tim[i] &gt; maxtim) &#123;</span><br><span class="line">            maxtim = tim[i];</span><br><span class="line">            top = <span class="number">0</span>;</span><br><span class="line">            stk[++top] = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tim[i] == maxtim)</span><br><span class="line">            stk[++top] = i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, maxtim);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= top; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str[stk[i]] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ed, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ed));</span><br><span class="line">    <span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(fail));</span><br><span class="line">    ct = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(t));</span><br><span class="line">    <span class="built_in">memset</span>(tim, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(tim));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">solv</span>();</span><br><span class="line">        <span class="built_in">clea</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Fail树"><a href="#Fail树" class="headerlink" title="Fail树"></a>Fail树</h3><p>Fail 指针构成了一个树形结构。</p>
<p>1.除了根节点都有 Fail 指针。</p>
<p>2.各个节点都能跳到根。</p>
<p>3.所以有 $N$ 个点 $N-1$ 条边，且连通，所以是树。</p>
<p><strong>【模板】AC自动机（二次加强版）(luoguP5357)</strong></p>
<p>给定一个文本串 $S$ 和 $n$ 个模式串 $T_{1\sim n}$，请你分别求出每个模式串 $T_i$ 在 $S$ 中出现的次数。</p>
<p>不保证任意两个模式串不同。</p>
<p>$1\le n\le2\times10^5$，$\sum_{i=1}^n|T_i|\le2\times10^5$，$|S|\le2\times10^6$。</p>
<hr>
<p>观察一下代码片段：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    pos = t[pos][tmp];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = pos; j; j = fail[j])</span><br><span class="line">        tim[ed[j]] ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现一个问题，就是 <code>j</code> 循环的部分，跳 <code>fail[j]</code> 实际上复杂度是不确定的，深度可能很深，复杂度会退化。</p>
<p>但是我们发现其实每次转移是类似的，可以建立出 <code>fail</code> 树然后通过遍历一遍 <code>fail</code> 树将所有转移都做了。</p>
<p>具体地，<code>j</code> 恰好使一个链都 <code>++</code>，于是我们可以在底端打一个标记，然后构建 <code>fail</code> 树后在树上做 DP 向上传递并累加。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>, M = <span class="number">2000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[M];</span><br><span class="line"><span class="keyword">int</span> ct, t[N][<span class="number">26</span>], fail[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ed[N];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> ctb, hd[N], ver[N&lt;&lt;<span class="number">1</span>], nxt[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> f[N];   <span class="comment">// 树形 DP</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ver[++ctb] = v;</span><br><span class="line">    nxt[ctb] = hd[u];</span><br><span class="line">    hd[u] = ctb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> rk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[pos][tmp] == <span class="number">0</span>)</span><br><span class="line">            t[pos][tmp] = ++ct;</span><br><span class="line">        pos = t[pos][tmp];</span><br><span class="line">    &#125;</span><br><span class="line">    ed[pos].<span class="built_in">push_back</span>(rk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line">        <span class="keyword">if</span>(t[<span class="number">0</span>][i])</span><br><span class="line">            q.<span class="built_in">push</span>(t[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">empty</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line">            <span class="keyword">if</span>(t[x][i]) &#123;</span><br><span class="line">                fail[t[x][i]] = t[fail[x]][i];</span><br><span class="line">                q.<span class="built_in">push</span>(t[x][i]);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                t[x][i] = t[fail[x]][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        pos = t[pos][tmp];</span><br><span class="line">        f[pos] ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = hd[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y, x);</span><br><span class="line">        f[x] += f[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmpsiz = ed[x].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmpsiz; i ++)</span><br><span class="line">        ans[ed[x][i]] += f[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="built_in">Insert</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="built_in">query</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ct; i ++) &#123;</span><br><span class="line">        <span class="built_in">add</span>(i, fail[i]);</span><br><span class="line">        <span class="built_in">add</span>(fail[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="阿狸的打字机-NOI2011-luoguP2414"><a href="#阿狸的打字机-NOI2011-luoguP2414" class="headerlink" title="阿狸的打字机 (NOI2011) (luoguP2414)"></a>阿狸的打字机 (NOI2011) (luoguP2414)</h4><p>有一个打字机，有 $28$ 个按键，分别是 $26$ 个小写英文字母和 <code>B</code>、<code>P</code> 两个字母，打字机是这样工作的：</p>
<ul>
<li>输入小写字母，会把这个字母加在凹槽最后。</li>
<li>按下 <code>B</code>，凹槽中的最后一个字母会消失</li>
<li>按下 <code>P</code>，会打印出凹槽中的字母，并换行，但凹槽中的字母不会消失</li>
</ul>
<p>给定一个字符串，表示按键情况。</p>
<p>然后把打印出来的字符串按照 $1\sim n$ 编号，有 $m$ 组询问，每次给定一个 $(x,y)$ 表示询问第 $x$ 个打印的字符串在第 $y$ 个打印的字符串中出现了多少次。</p>
<p>$1\le n\le10^5$，$1\le m\le10^5$，表示按键情况的字符串长度 $\le10^5$。</p>
<hr>
<p>最暴力的做法自然是跑 $m$ 遍 KMP，复杂度 $O(nm)$，是不能接受的。</p>
<p>本题的特点就在于它是由打字机打出来的，由于按键次数至多 $10^5$ 次，所以打出来的字符串相差必然都比较小。</p>
<p>如果放到 Trie 树上，必然不超过 $10^5$ 个节点。</p>
<p>我们想到构建 AC 自动机。</p>
<p>类似于 KMP，如果一个 fail 指针是从 $x$ 指向 $y$ 的，那么字符串 $y$ 在字符串 $x$ 中出现了一次。</p>
<p>对于一个字符串，从根到叶子，一路上每个节点都跳 fail 对应出来的若干个字符串全都在这个字符串内，并且不会漏，当然注意还要加上恰好就在这个串里的，即一路过来的这些子串。</p>
<p>于是我们可以在 Trie 树上 DFS，用一个全局桶，到每个节点跳 fail 把该加的都加进来。</p>
<p><del>然后光荣地 TLE 了。</del></p>
<p>跳 fail 复杂度是不对的，但是我们已经找到了策略，如何保证复杂度呢？</p>
<p>然后这时发现了一个问题，就是构建 AC 自动机太慢了，如果模拟的话，可能会插入许多许多次相同但很长的字符串，导致爆炸，于是我们需要特化本题的插入函数。</p>
<p>具体地，仍然是模拟，但是不从头插了，而是在 Trie 图上走，就可以保证复杂度。</p>
<p>然后我们就可以继续思考如何解决不可跳 fail 的问题。</p>
<p>分析可以发现，我们复杂度瓶颈在于一路上把各种串都插到桶里了，但是我们要查询的却比较少，于是我们考虑一对查询 $(x,y)$ 的关系。</p>
<p>按照上面的想法，就是 Trie 树上从根到 $y$ 一路上的点全插进来，fail 指针对应在 fail 树上的一条链全插进来，然后判断指向 $x$ 的个数，我们反向思考可以发现，只有 fail 树上 $x$ 的子树内的才能指向它，而且发现是一条链上全有贡献，所以子树内全都有贡献，于是我们每次不要跳 fail 到根，而是仅打一个标记，然后查 $x$ 只需要查 $x$ 子树内的标记数目。</p>
<p>然后这个东西可以数据结构优化，子树可以通过 DFS 序化为区间，然后就是单点修改区间查询。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, ct, tr[N][<span class="number">26</span>], tmptr[N][<span class="number">26</span>], fail[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> ctb, top, stk[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; strk[N];    <span class="comment">// 各个点对应的串的编号们</span></span><br><span class="line">vector&lt;pii&gt; qry[N];    <span class="comment">// 各个点的询问，第二关键字为询问序号</span></span><br><span class="line"><span class="keyword">int</span> p[N];   <span class="comment">// 第 i 个串在 Trie 中的位置</span></span><br><span class="line"><span class="keyword">int</span> cnt[N]; <span class="comment">// 全局桶，记录各个串出现次数，为了处理恰好就在这个串里的情况</span></span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> ctc, hd[N], ver[N&lt;&lt;<span class="number">1</span>], nxt[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> ctd, dfn[N], siz[N];</span><br><span class="line"><span class="keyword">int</span> t[N];   <span class="comment">// BIT</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ver[++ctc] = v;</span><br><span class="line">    nxt[ctc] = hd[u];</span><br><span class="line">    hd[u] = ctc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(tr[pos][tmp] == <span class="number">0</span>)</span><br><span class="line">                tr[pos][tmp] = ++ct;</span><br><span class="line">            stk[++top] = tr[pos][tmp];</span><br><span class="line">            pos = tr[pos][tmp];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">            top --;</span><br><span class="line">            pos = stk[top];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;P&#x27;</span>) &#123;</span><br><span class="line">            ++ ctb;</span><br><span class="line">            strk[pos].<span class="built_in">push_back</span>(ctb);</span><br><span class="line">            p[ctb] = pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(tmptr, tr, <span class="built_in"><span class="keyword">sizeof</span></span>(tr));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line">        <span class="keyword">if</span>(tmptr[<span class="number">0</span>][i]) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(tmptr[<span class="number">0</span>][i]);</span><br><span class="line">            fail[tmptr[<span class="number">0</span>][i]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">empty</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line">            <span class="keyword">if</span>(tmptr[x][i]) &#123;</span><br><span class="line">                fail[tmptr[x][i]] = tmptr[fail[x]][i];</span><br><span class="line">                q.<span class="built_in">push</span>(tmptr[x][i]);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                tmptr[x][i] = tmptr[fail[x]][i];    <span class="comment">// 这种方法会影响 Trie 树结构，所以我们需要新建一个副本来构建 fail 指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> dlt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; pos &lt;= ct+<span class="number">1</span>; pos += pos &amp; (-pos)) <span class="comment">// 注意有 ct+1 个点！</span></span><br><span class="line">        t[pos] += dlt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subquery</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; pos; pos -= pos &amp; (-pos))</span><br><span class="line">        ret += t[pos];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">subquery</span>(r) - <span class="built_in">subquery</span>(l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsa</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;  <span class="comment">// 给 fail 树标 dfn 标记并求出辅助的一些量</span></span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    dfn[x] = ++ctd;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = hd[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfsa</span>(y, x);</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmpsiz = strk[x].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmpsiz; i ++)</span><br><span class="line">    	cnt[strk[x][i]] ++; <span class="comment">// 把当前串插入桶</span></span><br><span class="line">    <span class="built_in">modify</span>(dfn[fail[x]], <span class="number">1</span>);    <span class="comment">// 打标记</span></span><br><span class="line">    tmpsiz = qry[x].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmpsiz; i ++) &#123;</span><br><span class="line">        pii ttmp = qry[x][i];</span><br><span class="line">        ans[ttmp.second] = cnt[ttmp.first] + <span class="built_in">query</span>(dfn[p[ttmp.first]], dfn[p[ttmp.first]] + siz[p[ttmp.first]] - <span class="number">1</span>);    <span class="comment">// 得到答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line">        <span class="keyword">if</span>(tr[x][i])</span><br><span class="line">            <span class="built_in">dfsb</span>(tr[x][i]); <span class="comment">// dfs</span></span><br><span class="line">    tmpsiz = strk[x].<span class="built_in">size</span>();   <span class="comment">// 回溯时撤回</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmpsiz; i ++)</span><br><span class="line">        cnt[strk[x][i]] --;</span><br><span class="line">    <span class="built_in">modify</span>(dfn[fail[x]], <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Insert</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, tx, ty; i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;tx, &amp;ty);</span><br><span class="line">        qry[p[ty]].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(tx, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ct; i ++) &#123;</span><br><span class="line">        <span class="built_in">addedge</span>(i, fail[i]);</span><br><span class="line">        <span class="built_in">addedge</span>(fail[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfsa</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">dfsb</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="魔法咒语-BJOI2017-luoguP3715"><a href="#魔法咒语-BJOI2017-luoguP3715" class="headerlink" title="魔法咒语 (BJOI2017) (luoguP3715)"></a>魔法咒语 (BJOI2017) (luoguP3715)</h4><p>给定 $n$ 个基本词汇，$m$ 个忌讳词语，它们都是字符串。求满足下列条件的字符串的个数：</p>
<p>1.长度等于 $L$。</p>
<p>2.可以被分割为若干个基本词汇。</p>
<p>3.不存在任何一个禁忌词语在字符串中出现过。</p>
<p>这里字符串不同的条件比较特殊：</p>
<p>把基本词汇标号 $1\sim n$，把字符串分割为若干个基本词汇，设 $i$ 号基本词汇的出现次数为 $c_i$，两个字符串不同当且仅当存在一个 $c_i$ 不相等。</p>
<p>而书写形式相同也可能是两个不同的字符串。</p>
<p>答案对 $10^9+7$ 取模。</p>
<p>$1\le n,m\le50$，$1\le L\le10^8$，当 $L&gt;100$ 时，保证基本词汇长度不超过 $2$，$M\le20$。</p>
<p>基本词汇长度之和、忌讳词语的长度之和不超过 $100$，基本词汇不重复，禁忌词汇不重复。</p>
<hr>
<p>由于字符串中不能出现忌讳词语，而判断是否出现忌讳词语就相当于匹配这个忌讳词语，容易想到要把所有忌讳词语插入 AC 自动机。</p>
<p>然后构建 fail 树并把所有不能到达的点做标记，然后在 AC 自动机上 DP，每次考虑加入一个基本词汇，然后枚举可以转移到的状态，为了使复杂度更优秀，我们可以 $O(n^3)$ 暴力预处理每个点插入每个字符串会到达的点，这样把我们 DP 的复杂度从 $O(L\times n^3)$ 优化到了 $O(L\times n^2)$。</p>
<p>这样，我们就解决了第一部分，本题另外一部分是 $L\le10^8$，但保证基本词汇长度不超过 $2$，这明显提示我们写矩乘。</p>
<p>这里已经不是这题在 AC 自动机方面作为例题的作用所在了，但还是说一下如何写吧。</p>
<p>主要还是建矩阵嘛。</p>
<p>设我们前面预处理那个数组是 $p[i][j]$，表示在点 $i$ 添加串 $j$ 到达的位置。转移都是形如下面这样的：</p>
<script type="math/tex; mode=display">
f[i][j]\rarr f[p[i][k]][j+l_k]</script><p>除了填完填了一位时不能填长度为 $2$ 的串以外，其他时候，转移都是随便填，这样就是个常系数的递推。</p>
<p>设初始列向量为 $f[0\sim ct][1],f[0\sim ct][0]$，然后矩阵的前 $ct+1$ 行就是看是否有转移，后 $ct+1$ 行是继承旧的前半部分。</p>
<p>当然，看是否有转移其实麻烦了，因为那样就还需要一个逆映射，没有必要，我们有 $p$ 这个映射就够了，我们仍然枚举所有转移，然后寻找转移在矩阵上的位置就行了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>, md = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    ll a[N&lt;&lt;<span class="number">1</span>][N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            a[i][i] = <span class="number">1ll</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _n, <span class="keyword">int</span> _m)</span> </span>&#123;</span><br><span class="line">        n = _n;</span><br><span class="line">        m = _m;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> * (Matrix B) &#123;</span><br><span class="line">        Matrix res;</span><br><span class="line">        res.<span class="built_in">init</span>(n, B.m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= B.m; j ++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; k ++)</span><br><span class="line">                    res.a[i][j] = (res.a[i][j] + a[i][k] * B.a[k][j]) % md;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Matrix <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        Matrix res, mat = *<span class="keyword">this</span>;</span><br><span class="line">        res.<span class="built_in">init</span>(n, n);</span><br><span class="line">        res.<span class="built_in">id</span>();</span><br><span class="line">        <span class="keyword">for</span>(; b; b &gt;&gt;= <span class="number">1</span>, mat = mat * mat)</span><br><span class="line">            <span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">                res = res * mat;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, l;</span><br><span class="line"><span class="keyword">char</span> s[N][N], tmps[N];</span><br><span class="line"><span class="keyword">int</span> len[N];</span><br><span class="line"><span class="keyword">int</span> ct, tr[N][<span class="number">26</span>], fail[N];</span><br><span class="line"><span class="keyword">bool</span> tag[N];    <span class="comment">// 忌讳词语标记</span></span><br><span class="line"><span class="keyword">int</span> ctb, hd[N], ver[N&lt;&lt;<span class="number">1</span>], nxt[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> p[N][N];   <span class="comment">// p[i][j] 表示在点 i，添加第 j 个串会到达哪里</span></span><br><span class="line"><span class="keyword">int</span> f[N][N]; <span class="comment">// 在点 i，填了 j 个字符的方案数</span></span><br><span class="line">Matrix st, trans;  <span class="comment">// 初始列向量，状态转移矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ver[++ctb] = v;</span><br><span class="line">    nxt[ctb] = hd[u];</span><br><span class="line">    hd[u] = ctb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(tr[pos][tmp] == <span class="number">0</span>)</span><br><span class="line">            tr[pos][tmp] = ++ct;</span><br><span class="line">        pos = tr[pos][tmp];</span><br><span class="line">    &#125;</span><br><span class="line">    tag[pos] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildfail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">0</span>][i])</span><br><span class="line">            q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">empty</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line">            <span class="keyword">if</span>(tr[x][i]) &#123;</span><br><span class="line">                fail[tr[x][i]] = tr[fail[x]][i];</span><br><span class="line">                q.<span class="built_in">push</span>(tr[x][i]);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                tr[x][i] = tr[fail[x]][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildfailtree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ct; i ++) &#123;</span><br><span class="line">        <span class="built_in">addedge</span>(i, fail[i]);</span><br><span class="line">        <span class="built_in">addedge</span>(fail[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">bool</span> flg)</span> </span>&#123;</span><br><span class="line">    flg |= tag[x];</span><br><span class="line">    tag[x] = flg;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = hd[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y, x, flg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= ct; i ++) &#123; <span class="comment">// 预处理 p[i][j]</span></span><br><span class="line">        <span class="keyword">if</span>(tag[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= len[j]; k ++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = s[j][k] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                pos = tr[pos][tmp];</span><br><span class="line">                <span class="keyword">if</span>(tag[pos]) &#123;</span><br><span class="line">                    p[i][j] = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p[i][j] != <span class="number">-1</span>)</span><br><span class="line">                p[i][j] = pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solv1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= l; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i + len[j] &gt; l)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= ct; k ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(tag[k] || p[k][j] == <span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                f[p[k][j]][i + len[j]] = (f[p[k][j]][i + len[j]] + f[k][i]) % md;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= ct; i ++)</span><br><span class="line">        ans = (ans + f[i][l]) % md;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solv2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(len[i] &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= ct; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tag[j] || p[j][i] == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            f[p[j][i]][<span class="number">1</span>] = (f[p[j][i]][<span class="number">1</span>] + f[j][<span class="number">0</span>]) % md;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    st.<span class="built_in">init</span>(<span class="number">2</span>*(ct+<span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ct+<span class="number">1</span>; i ++) &#123;   <span class="comment">// 初始列向量</span></span><br><span class="line">        st.a[i][<span class="number">1</span>] = f[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">        st.a[i+(ct+<span class="number">1</span>)][<span class="number">1</span>] = f[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    trans.<span class="built_in">init</span>(<span class="number">2</span>*(ct+<span class="number">1</span>), <span class="number">2</span>*(ct+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ct+<span class="number">2</span>; i &lt;= <span class="number">2</span>*ct+<span class="number">2</span>; i ++)    <span class="comment">// 下边直接继承的部分</span></span><br><span class="line">        trans.a[i][i-(ct+<span class="number">1</span>)] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)  <span class="comment">// 上边的部分</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= ct; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tag[j] || p[j][i] == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(len[i] == <span class="number">1</span>)</span><br><span class="line">                trans.a[p[j][i] + <span class="number">1</span>][j+<span class="number">1</span>] ++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trans.a[p[j][i] + <span class="number">1</span>][(j+<span class="number">1</span>) + (ct+<span class="number">1</span>)] ++;</span><br><span class="line">        &#125;</span><br><span class="line">    trans = trans.<span class="built_in">qpow</span>(l<span class="number">-1</span>);</span><br><span class="line">    st = trans * st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ct+<span class="number">1</span>; i ++)</span><br><span class="line">        ans = (ans + st.a[i][<span class="number">1</span>]) % md;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i]+<span class="number">1</span>);</span><br><span class="line">        len[i] = <span class="built_in">strlen</span>(s[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tmps);</span><br><span class="line">        <span class="built_in">Insert</span>(tmps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">buildfail</span>();</span><br><span class="line">    <span class="built_in">buildfailtree</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">getp</span>();</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= <span class="number">100</span>)</span><br><span class="line">        <span class="built_in">solv1</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">solv2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机</title>
    <url>/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><h2 id="概念描述："><a href="#概念描述：" class="headerlink" title="概念描述："></a>概念描述：</h2><p>AC自动机：<del>（一种可以自动AC的机器）</del>，指的是一个文本串和若干个模式串看看这些模式串是否在文本串上被匹配（不需要管有几次，只要出现过就行）</p>
<h2 id="核心思想："><a href="#核心思想：" class="headerlink" title="核心思想："></a>核心思想：</h2><h4 id="fail指针"><a href="#fail指针" class="headerlink" title="fail指针"></a>fail指针</h4><p>fail指针（这是早期oier们针对此题的一个指针的定义，没有多么高级，只是说明当你匹配成功或者失败后，你要去向何处）在trie上的一些应用来简化</p>
<h4 id="trie树"><a href="#trie树" class="headerlink" title="trie树"></a>trie树</h4><p>直接把一个字符串一棵树上，把它们相同的部分连在一起，方便统一处理</p>
<h3 id="trie树-1"><a href="#trie树-1" class="headerlink" title="trie树"></a>trie树</h3><p>trie树是一种很暴力但是很有用的一种数据结构</p>
<p>trie树是维护一棵树，它的每个节点都会有一些儿子，当我们插入一个新的字符串时，会从第一位开始找，看看树上是否已经有了这个节点，如果找到了就去它的儿子节点去找它的下一位，如果没有就对于这个新的节点建一个新的节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ZPK</span>&#123;</span><span class="comment">//AωR2020 txdy</span></span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">&#125;trie[N];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> s[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;s[i];i++)&#123;</span><br><span class="line">       	<span class="keyword">int</span> v=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!trie[u].son[v]) trie[u].son[v]=++tot;</span><br><span class="line">        u=trie[u].son[v];</span><br><span class="line">    &#125;</span><br><span class="line">    trie[u].num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是基本思想和代码了，每次读入一个字符串，直接insert即可</p>
<p>总而言之，言而总之：</p>
<p>$\Huge 有路找路走，没路自己开路走$</p>
<p>这是我学习trie树的一点点经验</p>
<h3 id="get-fail"><a href="#get-fail" class="headerlink" title="get_fail"></a>get_fail</h3><p>先放上来一个图（<a href="https://www.cnblogs.com/hyfhaha/p/10802604.html">来源</a>）</p>
<p><img src="https://files.catbox.moe/q6ywlu.png" alt=""></p>
<p>首先我们要先get一下fail指针的具体含义：</p>
<p>如果说一个点$i$的$fail$指针指向$j$，那么$root$到$j$一定是$root$到$i$这个字符串的前缀</p>
<p>那么我们一个字符的fail指针可能指向很多个数</p>
<p>我们还是拿上面的图举例子</p>
<p>$i$:4     $j$:7<br>$root$到$i$的字符串是“ABC”<br>$root$到$j$的字符串是“BC”<br>“BC”是“ABC”的一个后缀<br>“C”也是“ABC”的一个后缀<br>所以$i$的$Fail$指针指向$j$，意味着:</p>
<p>我们的$fail$指针指向的应该还得是这些后缀中$\text{dep}$<strong>最大</strong>的那个</p>
<p>这个$fail$指针看起来好牛逼啊</p>
<p>那么我们怎么办get到这个$fail$呢</p>
<p>我们想到了一些问题，对于字符串ABC和BC来说，其实我们</p>
<p>完全不需要去进行从后往前的枚举，我们要牢牢记得我们是建了一个trie树的</p>
<p>我们从上往下进行时，我们首先可以确定一件事情就是我们的$fail$指针指向的那个点的$\text{dep}$一定币当前节点小，所以我们首先可以确定第一层的点的fail都是指向节点$\text{root}$的</p>
<p>我们考虑中间一个点$i$的$\text{fa}$的$fail$指针指的是$\Large Fail$</p>
<p>如果$Fail$有和$i$相等的儿子的话那么就让$i$的$fail$值指向那个点，因为我们要维护若干个用父亲的$fail$，所以用$\text{bfs}$可能对于本题更为合适</p>
<p>然后我们再来看一个图（截自OI-wiki）</p>
<p><img src="https://files.catbox.moe/1bo2gf.png" alt=""></p>
<p> 找到 6 的父结点 5，$fail[5]=10$。然而 10 结点没有字母 <code>s</code> 连出的边；继续跳到 10 的 $fail$指针，fail[10]=5。发现 0 结点有字母 <code>s</code> 连出的边，指向 7 结点；所以$fail[6]=7$。</p>
<h4 id="实现细节与技巧"><a href="#实现细节与技巧" class="headerlink" title="实现细节与技巧"></a>实现细节与技巧</h4><ol>
<li><p>我们可以直接将每个点连到0号节点，然后我们将0号节点的所有儿子指向$root$一节点</p>
</li>
<li><p>如果$trie[u]$的儿子$i$是空的，那么我们可以将那个节点设为$Fail$的<strong>(值和$i$相同)</strong>的儿子。保证存在性，就算是0也可以成功返回到根，因为0的所有儿子都是根。</p>
</li>
<li><p>无论$Fail$存不存在和$i$值相同的儿子$j$，我们都可以将$i$的$fail$指向$j$，原因是处理$i$时$j$已经处理好了。</p>
</li>
<li><p>实现时不记父亲，我们直接让父亲更新儿子</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) trie[<span class="number">0</span>].son[i]=<span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    trie[<span class="number">1</span>].fail=<span class="number">0</span>;<span class="comment">//将rt压入队列</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">       	<span class="keyword">int</span> u=q.<span class="built_in">front</span>(),v=q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> Fail=trie[u].fail;</span><br><span class="line">            <span class="keyword">int</span> v=trie[u].son[i];</span><br><span class="line">            <span class="keyword">if</span>(!v)&#123;</span><br><span class="line">                trie[u].son[i]=trie[Fail].son[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                trie[v].fail=trie[Fail].son[i];</span><br><span class="line">            	q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h3><p>求出了$fail$指针后，如果一个字符串匹配成功，那么他的$fail$肯定也成功，它的$fail$的$fail$也可以成功，经过的点累加flag，标记为-1，然后我们跑的时候就不会被重复计算了。（也可以这么理解，如果你跑过这个点了，它的fail会使它一路跳到根，你会发现其实它们都是不需要的）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u=<span class="number">1</span>,ans=<span class="number">0</span>,len=<span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> v=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">int</span> k=trie[u].son[v];		<span class="comment">//跳Fail</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">while</span>(k&gt;<span class="number">1</span> &amp;&amp; trie[k].flag!=<span class="number">-1</span>)&#123;<span class="comment">//经过就不统计了</span></span><br><span class="line">			ans+=trie[k].flag,trie[k].flag=<span class="number">-1</span>;	</span><br><span class="line">             <span class="comment">//累加上这个位置的模式串个数，标记该点已经经过</span></span><br><span class="line">			k=trie[k].fail;			<span class="comment">//继续跳Fail</span></span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		u=trie[u].son[v];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e6</span>+<span class="number">5</span>;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>; <span class="keyword">char</span> c=<span class="built_in">getchar</span>(); <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c=<span class="built_in">getchar</span>()) f |= c==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c=<span class="built_in">getchar</span>()) x = x*<span class="number">10</span>+(c^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">if</span>(f) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T &amp;x,<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">short</span> st[<span class="number">30</span>],tp;</span><br><span class="line">    <span class="keyword">do</span> st[++tp] = x%<span class="number">10</span>, x/=<span class="number">10</span>; <span class="keyword">while</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(tp) <span class="built_in">putchar</span>(st[tp--] | <span class="number">48</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ZPK</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num,fail;</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">30</span>];</span><br><span class="line">&#125;trie[N];</span><br><span class="line"><span class="keyword">int</span> n,tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> s[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!trie[u].son[v]) trie[u].son[v]=++tot;</span><br><span class="line">        u=trie[u].son[v];</span><br><span class="line">    &#125;</span><br><span class="line">    trie[u].num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getfail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(trie[<span class="number">0</span>].son[i]) q.<span class="built_in">push</span>(trie[<span class="number">0</span>].son[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=trie[u].son[i];</span><br><span class="line">            <span class="keyword">int</span> Fail=trie[u].fail;</span><br><span class="line">            <span class="keyword">if</span>(!v) trie[u].son[i]=trie[Fail].son[i];</span><br><span class="line">            <span class="keyword">else</span> trie[v].fail=trie[Fail].son[i],q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> s[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> k=trie[u].son[v];</span><br><span class="line">        <span class="keyword">while</span>(k &amp;&amp; trie[k].num!=<span class="number">-1</span>)&#123;</span><br><span class="line">            ans+=trie[k].num;</span><br><span class="line">            trie[k].num=<span class="number">-1</span>;</span><br><span class="line">            k=trie[k].fail;</span><br><span class="line">        &#125;</span><br><span class="line">        u=trie[u].son[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="built_in">insert</span>(s,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getfail</span>();</span><br><span class="line">    <span class="built_in">memset</span>(s,<span class="string">&#x27;\0&#x27;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(s));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="built_in">query</span>(s,len);</span><br><span class="line">    <span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="加强版"><a href="#加强版" class="headerlink" title="加强版"></a>加强版</h2><p>刚才我们问的是一个字符串是否在文本串中出现，</p>
<p>现在我们换一个问法，问你哪个字符串出现次数最多，是多少,并输出该字符串</p>
<p>然后我们给每个店的num直接改成这个点所对应的id，每次这个id++就行了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ZPK</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> num,fail;</span><br><span class="line">&#125;trie[N];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="keyword">int</span> ed[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">char</span> c[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">0</span>,len=<span class="built_in">strlen</span>(c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=c[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!trie[u].son[v]) trie[u].son[v]=++tot;</span><br><span class="line">        u=trie[u].son[v];</span><br><span class="line">    &#125;</span><br><span class="line">    trie[u].num=now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getfail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span>(trie[<span class="number">0</span>].son[i]) q.<span class="built_in">push</span>(trie[<span class="number">0</span>].son[i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=trie[u].son[i];</span><br><span class="line">            <span class="keyword">int</span> Fail=trie[u].fail;</span><br><span class="line">            <span class="keyword">if</span>(!v) trie[u].son[i]=trie[Fail].son[i];</span><br><span class="line">            <span class="keyword">else</span> trie[v].fail=trie[Fail].son[i],q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> c[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(c);</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=c[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> k=trie[u].son[v];</span><br><span class="line">        <span class="keyword">while</span>(k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(trie[k].num) ed[trie[k].num]++;</span><br><span class="line">            k=trie[k].fail;</span><br><span class="line">        &#125;</span><br><span class="line">        u=trie[u].son[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ed,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(ed));</span><br><span class="line">    <span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(trie));</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n &amp;&amp; n)&#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">200</span>][<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]);</span><br><span class="line">            <span class="built_in">insert</span>(i,s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">getfail</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[n+<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">query</span>(s[n+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) ans=<span class="built_in">max</span>(ans,ed[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) <span class="keyword">if</span>(ed[i]==ans) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,s[i]);</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二次加强版"><a href="#二次加强版" class="headerlink" title="二次加强版"></a>二次加强版</h2>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/KMP/</url>
    <content><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="前提介绍"><a href="#前提介绍" class="headerlink" title="前提介绍"></a>前提介绍</h2><p>KMP算法是一种看模式串在主串中出现次数的优化算法 复杂度为O（n+m）</p>
<p>这个算法理解了不难，不理解只背模板早晚会挂，而且容易忘，建议从头到尾一步一步看完</p>
<p>为了方便描述，我们把S作为子串，T作为模式串,然后下标一定要从1开</p>
<p>设len1为长串，len2为模式串（即短串）</p>
<p>本讲解是参考李煜东蓝书的，把部分不易懂的写了出来，希望对大家有帮助</p>
<p><a href="https://www.luogu.com.cn/problem/P3375">洛谷P3375【模板】KMP字符串匹配</a></p>
<h2 id="next数组求解"><a href="#next数组求解" class="headerlink" title="next数组求解"></a>next数组求解</h2><p>短串:    A  B  A  B  A  A</p>
<p>下标:    1  2   3  4  5  6</p>
<p>数组:    0  0   1  2  3  1</p>
<p>数组指nxt数组</p>
<p>nxt[2]代表s[1]~s[2]即”AB”，前缀为”A”，后缀为“B”，共有元素的长度为0.</p>
<p>nxt[3]代表s[1]~s[3]即”ABA”，前缀为”AB”，后缀为”BA”，最大前后缀即”A”,长度为1.</p>
<p>nxt[4]代表s[1]-s[4]即”ABAB”，前缀为”ABA”后缀为“BAB”，最大前后缀即”AB”,长度为2.</p>
<p>nxt[5]代表s[1]~s[5]即”ABABA”,前缀为”ABAB”，后缀为”BABA”,最大前后缀即”ABA”,长度为3.</p>
<p>nxt[i] 表示从第1位到第i位 除去前后都是自身的最大前后缀（所以上面的例子不能有nxt[6]）</p>
<p>我们先好好理解一下nxt数组的意思，然后大声喊十遍：<code>nxt是最大前后缀，nxt是最大前后缀，nxt是最大前后缀，nxt是最大前后缀，nxt是最大前后缀，nxt是最大前后缀，nxt是最大前后缀，nxt是最大前后缀，nxt是最大前后缀，nxt是最大前后缀，</code></p>
<p>相信大家都已经喊完了，或者跳过了，然后我们看如何求解nxt数组：</p>
<h3 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h3><p>对于 $A[1 - i]$依次枚举  $j∈[1,i-1]$, 并检查  $A[i-j+1,i]$ 和  $A[1,j]$,复杂度$O((len2)^3)$</p>
<p>然后我尝试着写了份代码(最好还是看一看挺好懂的)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len2;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j;j--)&#123;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k=i-j;<span class="comment">//k是用来检验后串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">1</span>;n&lt;=j;n++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[n]!=t[k+n])&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            nxt[i]=<span class="built_in">max</span>(nxt[i],j);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KMP优化"><a href="#KMP优化" class="headerlink" title="KMP优化"></a>KMP优化</h3><p>在讲KMP思想之前</p>
<p>我们先证明几个有关KMP的引理</p>
<h4 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h4><p>我们先引入一个概念：候选项</p>
<p>如果存在一个j使得$A[1,j]$和$A[i-j+1,i]$相等，那么我们就能认为$j$是$nxt[i]$的一个候选项，很显然，$1 \le j \le nxt[i]$</p>
<p>现在我们需要证明：若$j_0$是$nxt[i]$的一个候选项，则小于$j_0$的最大的$nxt[i]$的候选项是$nxt[j_0]$。换言之，$[nxt[j_0]+1,j_0-1]$之间一定不含$nxt[i]$的候选项</p>
<p>这个玩意很重要，看出来这个你的kmp就学完了</p>
<p>这个要用反证法：</p>
<p>假设在$[nxt[j_0]+1,j_0-1]$之间存在一个$j_1$可以当作候选项</p>
<p>我们可以发现，若$j_1$是候选项我们可以列出下面两个式子</p>
<p>$A[1,j_1]$ = $A[i-j_1+1,i]$</p>
<p>$A[1,j_0]$ = $A[i-j_0+1,i]$</p>
<p>然后由于是前后缀，所以说第二个式子的每边的后k个也是相等的</p>
<p>$A[j_0-k+1,j_0]$ = $A[i-k+1,i]$</p>
<p>我们钦定$k=j_1$</p>
<p>所以说</p>
<p>$A[j_0-j_1+1,j_0]$ = $A[i-j_1+1,i]$</p>
<p>发现和第一个式子有重合，直接把第二个式子换成</p>
<p>$A[1,j_1]$ = $A[j_0-j_1+1,j_0]$</p>
<p>与$nxt[j_0]$的<strong>最大</strong>的性质不符，故假设不成立，即引理正确</p>
<p>如果看不懂，不用看上面的一堆式子直接看图就明白了！</p>
<p>设最浅的块是a，其次是b，最深的是c</p>
<p>则：$c$为$nxt[j_0]$</p>
<p>$b+c$ 为 $j_1$</p>
<p>$a+b+c$ 是 $j_0$<br><img src="https://img2020.cnblogs.com/blog/1823105/202110/1823105-20211026222145698-442157332.png" alt="image"></p>
<h4 id="KMP的操作及实现"><a href="#KMP的操作及实现" class="headerlink" title="KMP的操作及实现"></a>KMP的操作及实现</h4><p>由刚才我们发现的这一性质，我们可以发现KMP的若干性质</p>
<p>1.我们可以发现当$nxt[i-1]$确认时，我们就可以知道$nxt[i]$的所有border从大到小是$nxt[nxt[i]]$，$nxt[nxt[nxt[i]]]$……</p>
<p>2.我们还可以发现若$j$是$nxt[i]$的border，那么$j-1$也是$nxt[i-1]$的border</p>
<h5 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h5><p>这个证明很显然，$j$如果说是$nxt[i]$的border，则$A[i-j+1,i]$和$A[1,j]$相等</p>
<p>所以说$A[i-j+1,i-1]$和$A[1,j-1]$必然相等</p>
<p>所以我们在计算$nxt[i]$时，只需要把$nxt[i-1]+1$ , $nxt[nxt[i-1]]+1$ , $nxt[nxt[nxt[i-1]]]+1$ ……</p>
<p>作为border即可，且它们一定是从大到小排列</p>
<p>最后，我们就可以告诉大家怎么求了</p>
<p>首先，我们把$nxt[1]$赋为0</p>
<p>假设我们已经处理到第$i$位($2\leq i\leq len$)</p>
<p>那么此时$nxt[1]$到$nxt[i]$的值都是已知的</p>
<p>我们假设当前的候选项是$j$</p>
<p>我们要处理$i+1$时，若$j+1$和$i+1$不可以匹配就让$j$跳到$nxt[i]$，若可以匹配或者现在border已经变成0了，就要把$nxt[i+1]$搞成$j$</p>
<p>放个代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> nxt[N];<span class="keyword">char</span> s[N],t[N];</span><br><span class="line"><span class="keyword">int</span> n,m,f[N];<span class="comment">//s是短串，t是长串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nxt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(s[j+<span class="number">1</span>]!=s[i] &amp;&amp; j) j=nxt[j];</span><br><span class="line">        <span class="keyword">if</span>(s[j+<span class="number">1</span>]==s[i]) j++;</span><br><span class="line">        nxt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后有人要问了，那你求$nxt$有什么意义吗，我们要求的不是$nxt$啊</p>
<p>那么我们此时再假设一个$f$数组表示$f[i]=max${$j$}，$j$表示S的前j位与T的$T[i-j+1,i]$位相等</p>
<p>我们发现是不是$f$数组的定义其实和$T$数组几乎一样啊</p>
<p>所以我们可以直接用求$nxt$数组的思想，写出求长串的思想：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; (s[j+<span class="number">1</span>]!=t[i] || j==n)) j=nxt[j];</span><br><span class="line">        <span class="keyword">if</span>(s[j+<span class="number">1</span>]==t[i]) j++;</span><br><span class="line">        f[i]=j</span><br><span class="line">        <span class="keyword">if</span>(f[i]==n) cout&lt;&lt;i-n+<span class="number">1</span>&lt;&lt;endl;<span class="comment">//如果S串整个串都出现了，就输出匹配的第一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>图的存储和遍历模板</title>
    <url>/Tarjan%E5%BC%80%E4%B8%9A/</url>
    <content><![CDATA[<h1 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h1><h2 id="割点、割边（桥）"><a href="#割点、割边（桥）" class="headerlink" title="割点、割边（桥）"></a>割点、割边（桥）</h2><p>对于<strong>无向连通图</strong> $G=(V,E)$：</p>
<p>若对于 $x\in V$，从图中删去 $x$ 以及与其直接相连的点之后，$G$ 不再连通，则称 $x$ 为 $G$ 的<strong>割点</strong>。</p>
<p>若对于 $e\in E$，从图中删去 $e$ 后，$G$ 不再连通，则称 $e$ 为 $G$ 的<strong>割边</strong>或<strong>桥</strong>。</p>
<p><strong>一般无向图</strong>（不一定连通）的割点和桥就是它的各个连通块的割点和桥。</p>
<hr>
<h2 id="Tarjan-求割边（桥）、割点"><a href="#Tarjan-求割边（桥）、割点" class="headerlink" title="Tarjan 求割边（桥）、割点"></a>Tarjan 求割边（桥）、割点</h2><p>$low[x]$ 定义为搜索树中 $x$ 的子树以及经过一条非树边可以到达搜索树中 $x$ 的子树的节点的 $dfn[y]$ 的最小值。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>具体题中一定要注意图是否连通。</p>
<h3 id="求割边（桥）"><a href="#求割边（桥）" class="headerlink" title="求割边（桥）"></a>求割边（桥）</h3><ul>
<li>判定法则</li>
</ul>
<p>无向边 $(x,y)$ 是桥，当且仅当搜索树上 $y$ 是 $x$ 的子节点，且满足 $low[y]&gt;dfn[x]$。</p>
<ul>
<li>性质以及一个奇怪的操作</li>
</ul>
<p><strong>桥一定是搜索树中的边，一个简单环中的边一定都不是桥。割边必然在生成树中。</strong></p>
<p>如果一个边不属于任何一个回路，那么它是一条割边。</p>
<p>利用此性质，可以求出任意一个生成树，然后向上加非树边，没有和任意一个非树边构成环的边就是割边，覆盖成环的操作可以使用树上差分，还可以使用树剖。</p>
<ul>
<li>Tarjan 求桥</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> in_edge)</span> </span>&#123;</span><br><span class="line">    ctb ++;</span><br><span class="line">    dfn[x] = low[x] = ctb;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = hd[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i];</span><br><span class="line">        <span class="keyword">if</span>(dfn[y] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y, i);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            <span class="keyword">if</span>(low[y] &gt; dfn[x])</span><br><span class="line">                bri[i] = bri[i ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i != (in_edge ^ <span class="number">1</span>))</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="边-S2OJ391"><a href="#边-S2OJ391" class="headerlink" title="边 (S2OJ391)"></a>边 (S2OJ391)</h4><p>给定一张图，判断其中的每条边在最小生成树中的情况：</p>
<p>​    1.不在任意一个最小生成树中，输出 <code>none</code>。</p>
<p>​    2.在部分最小生成树中，输出 <code>at least one</code>。</p>
<p>​    3.一定出现在最小生成树中，输出 <code>any</code>。</p>
<p>按照读入的顺序输出每条边的情况。</p>
<p>$n,m\le10^5$。</p>
<hr>
<p>利用加边再断环的想法，用向上标记法，可以水过去（数据太水了，这种方法复杂度不对，会被卡到 $O(n^2)$）。</p>
<p><code>none</code> 是好判断的，所以我们重点在于如何判断是 <code>any</code> 还是 <code>at least one</code>。</p>
<p>对于任意一个连通森林，连接两个连通块的权值最小的边一定在最小生成树中。但是如果有连接两个相同连通块的边权值相同，这两个边就会出现问题，从 <code>any</code> 变成了 <code>at least one</code>。</p>
<p>我们仔细思考上面的情况，可以发现问题出现在这种情况：有若干条权值相同的边，并且它们都可以连接两个不同的连通块。</p>
<p>那么，把连通块看成点，把这些权值相同的边加入，那么在这个图中的桥，都是 <code>any</code>，否则是 <code>at least one</code>。</p>
<p>那么我们跑一遍 $\rm Tarjan$，复杂度是 $O(边数)$ 的，所以总复杂度约 $O(m)$。</p>
<p>当然那时 $\rm Tarjan$ 的总复杂度，整个程序还有排序和并查集，是一个小常数 $O(n\log n)$。</p>
<p>这种将连通块看作点，以及多次判断是否为桥时的处理方法是很值得借鉴与思考的。</p>
<p>好题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> rk, u, v, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Disjoint_Set</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> fa[N];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">djsinit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; i ++)</span><br><span class="line">			fa[i] = i;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">Find</span>(fa[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		x = <span class="built_in">Find</span>(x);</span><br><span class="line">		y = <span class="built_in">Find</span>(y);</span><br><span class="line">		fa[x] = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> ct = <span class="number">1</span>, hd[N], ver[N&lt;&lt;<span class="number">1</span>], nxt[N&lt;&lt;<span class="number">1</span>], rk[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line">Edge e[N];</span><br><span class="line">Disjoint_Set djs;</span><br><span class="line">vector&lt;Edge&gt; tmpe;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; tmpp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> rank)</span> </span>&#123;</span><br><span class="line">	ver[++ct] = v;</span><br><span class="line">	rk[ct] = rank;</span><br><span class="line">	nxt[ct] = hd[u];</span><br><span class="line">	hd[u] = ct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tarjan &#123;</span><br><span class="line">	<span class="keyword">int</span> ct, dfn[N], low[N];</span><br><span class="line">	<span class="keyword">int</span> st;	<span class="comment">// 用于表示开始一轮 Tarjan 时 ct 的值。 </span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> ine)</span> </span>&#123;</span><br><span class="line">		ct ++;</span><br><span class="line">		dfn[x] = low[x] = ct;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = hd[x]; i; i = nxt[i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> y = ver[i];</span><br><span class="line">			<span class="keyword">if</span>(dfn[y] == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">tarjan</span>(y, i);</span><br><span class="line">				low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">				<span class="keyword">if</span>(low[y] &gt; dfn[x])</span><br><span class="line">					ans[rk[i]] = <span class="number">2</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(i != (ine ^ <span class="number">1</span>) &amp;&amp; dfn[y] &gt; st)	<span class="comment">// 防止使</span></span><br><span class="line">				low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		st = ct;</span><br><span class="line">		<span class="keyword">int</span> siz = tmpp.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; siz; i ++)</span><br><span class="line">			dfn[tmpp[i]] = low[tmpp[i]] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; siz; i ++)</span><br><span class="line">			<span class="keyword">if</span>(dfn[tmpp[i]] == <span class="number">0</span>)</span><br><span class="line">				<span class="built_in">tarjan</span>(tmpp[i], <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	e[m+<span class="number">1</span>].w = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;e[i].u, &amp;e[i].v, &amp;e[i].w);</span><br><span class="line">		e[i].rk = i;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">sort</span>(e+<span class="number">1</span>, e+m+<span class="number">1</span>, cmp);</span><br><span class="line">	djs.<span class="built_in">djsinit</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m;) &#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = e[i].w;</span><br><span class="line">		<span class="keyword">while</span>(e[i].w == tmp) &#123;</span><br><span class="line">			<span class="keyword">int</span> tx = djs.<span class="built_in">Find</span>(e[i].u);</span><br><span class="line">			<span class="keyword">int</span> ty = djs.<span class="built_in">Find</span>(e[i].v);</span><br><span class="line">			<span class="keyword">if</span>(tx == ty) &#123;</span><br><span class="line">				i ++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ans[e[i].rk] = <span class="number">1</span>;</span><br><span class="line">			Edge tmp2;</span><br><span class="line">			tmp2.rk = e[i].rk;</span><br><span class="line">			tmp2.u = tx;</span><br><span class="line">			tmp2.v = ty;</span><br><span class="line">			tmp2.w = e[i].w;</span><br><span class="line">			tmpe.<span class="built_in">push_back</span>(tmp2);</span><br><span class="line">			i ++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> siz = tmpe.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; siz; j ++) &#123;</span><br><span class="line">			Edge tmp3 = tmpe[j];</span><br><span class="line">			<span class="built_in">add</span>(tmp3.u, tmp3.v, tmp3.rk);</span><br><span class="line">			<span class="built_in">add</span>(tmp3.v, tmp3.u, tmp3.rk);</span><br><span class="line">			djs.<span class="built_in">Merge</span>(tmp3.u, tmp3.v);</span><br><span class="line">			tmpp.<span class="built_in">push_back</span>(tmp3.u);</span><br><span class="line">			tmpp.<span class="built_in">push_back</span>(tmp3.v);</span><br><span class="line">		&#125;</span><br><span class="line">		tmpe.<span class="built_in">clear</span>();</span><br><span class="line">		Tarjan::<span class="built_in">mian</span>();</span><br><span class="line">		tmpp.<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">		<span class="keyword">if</span>(ans[i] == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;none&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ans[i] == <span class="number">1</span>)</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;at least one&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;any&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<h3 id="求割点"><a href="#求割点" class="headerlink" title="求割点"></a>求割点</h3><p>若 $x$ 是搜索树的根节点，则 $x$ 是割点当且仅当搜索树上存在至少两个子节点 $y_1,y_2$ 满足 $low[y_i]\ge dfn[x]$。</p>
<p>若 $x$ 不是搜索树的根节点，那么 $x$ 是割点当且仅当搜索树上存在一个 $x$ 的子节点 $y$ 满足 $low[y]\ge dfn[x]$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ctb ++;</span><br><span class="line">    dfn[x] = low[x] = ctb;</span><br><span class="line">    <span class="keyword">int</span> tmpcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = hd[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i];</span><br><span class="line">        <span class="keyword">if</span>(dfn[y] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            <span class="keyword">if</span>(low[y] &gt;= dfn[x])</span><br><span class="line">                tmpcnt ++;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((x != rt &amp;&amp; tmpcnt == <span class="number">1</span>) || tmpcnt &gt; <span class="number">1</span>)</span><br><span class="line">        cut[x] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="强连通分量（SCC）"><a href="#强连通分量（SCC）" class="headerlink" title="强连通分量（SCC）"></a>强连通分量（SCC）</h2><p>定义在<strong>有向图</strong>上。</p>
<p>一张有向图，满足图中任意两个节点 $x,y$，都存在至少一条 $x$ 到 $y$ 的路径，那么是一张强连通图。</p>
<p>有向图的极大强连通子图称为“强连通分量”，简记为 SCC。</p>
<hr>
<h2 id="Tarjan-求强连通分量"><a href="#Tarjan-求强连通分量" class="headerlink" title="Tarjan 求强连通分量"></a>Tarjan 求强连通分量</h2><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>具体题中一定要注意图是否连通。</p>
<p>当然，其实连不连通都得从每个 $dfn[x]=0$ 的点搜一遍，因为有向图的连通比较难搞。</p>
<hr>
<p>首先维护一个栈，包含 $x$ 的祖先节点和存在一条路径到达 $x$ 的祖先节点的点，那么如果从 $x$ 出发有一条边连接到了这些点，就可以形成环。</p>
<ul>
<li>SCC 简单性质</li>
</ul>
<p>任意一个点或边都在至少一个简单环中。</p>
<ul>
<li>$low[x]$</li>
</ul>
<p>定义为栈中的或者搜索树上 $x$ 的子树内有边连向 $x$ 的点的 $dfn[y]$ 的最小值。</p>
<p>进行 DFS，把搜索树上的点入栈，如果目标节点在栈中，则用 $dfn[y]$ 更新 $low[x]$，否则可以用 $low[y]$ 更新 $low[x]$。</p>
<p>不难发现，一个 SCC 中所有节点的 $low[x]$ 都等于 SCC 中最小的 $dfn[x]$，考虑让每个 SCC 是在它第一个被搜到的节点处统计，于是，我们在 $low[x]=dfn[x]$ 的点 $x$ 处统计，具体地，不断出栈，直至 $x$ 也出栈。</p>
<p>每个节点都包含在至少一个 SCC 中，因为实在不行它可以自己成一个 SCC，毕竟初始化 $low[x]=dfn[x]=cnt$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ctb ++;</span><br><span class="line">    dfn[x] = low[x] = ctb;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">    ins[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = hd[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i];</span><br><span class="line">        <span class="keyword">if</span>(dfn[y] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ins[y])</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[x] == dfn[x]) &#123;</span><br><span class="line">        ctc ++;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk[top--];</span><br><span class="line">            ins[y] = <span class="literal">false</span>;</span><br><span class="line">            bel[y] = ctc;</span><br><span class="line">            scc[ctc].<span class="built_in">push_back</span>(y);</span><br><span class="line">        &#125; <span class="keyword">while</span>(x != y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="SCC-缩点"><a href="#SCC-缩点" class="headerlink" title="SCC 缩点"></a>SCC 缩点</h3><p>把 SCC 看作一个点，只把不在同一个 SCC 的边连上即可。</p>
<hr>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>dsu on tree</title>
    <url>/dsu%20on%20tree/</url>
    <content><![CDATA[<h2 id="dsu-on-tree"><a href="#dsu-on-tree" class="headerlink" title="dsu on tree"></a>dsu on tree</h2><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><blockquote>
<p> dfs建树  轻重链剖分</p>
</blockquote>
<h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><blockquote>
<p>对于以 u 为根的子树</p>
<p>①. 先统计它轻子树(轻儿子为根的子树)的答案，统计完后删除信息</p>
<p>②. 再统计它重子树(重儿子为根的子树)的答案 ，统计完后保留信息</p>
<p>③. 然后再将重子树的信息合并到 u上</p>
<p>④. 再去遍历 u 的轻子树，然后把轻子树的信息合并到 u 上</p>
<p>⑤. 判断 u 的信息是否需要传    递给它的父节点（u 是否是它父节点的重儿子）</p>
</blockquote>
<p>首先我们进行 $\mathrm{dfs}$ 找出节点的重儿子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    fa[u] = f;</span><br><span class="line">    siz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v == f) <span class="keyword">continue</span>;</span><br><span class="line">       	<span class="built_in">dfs</span>(v, u);</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[v] &gt; siz[son[u]]) son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们进行统计答案的操作</p>
<p>首先标记好是要进行添加还是删除</p>
<p>然后我们像上面说的一样，先统计完轻字数的答案，然后删除信息，然后再统计答案</p>
<p>最后放出总代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BlackPink is the Revolution</span></span><br><span class="line"><span class="comment">light up the sky</span></span><br><span class="line"><span class="comment">Blackpink in your area</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); (i) &lt;= (b); ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); (i) &gt;= (b); --i) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> whlie while</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int (i) = (l); (i) &lt;= (r); (i)++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pre(i, l, r) for(int (i) = (l); (i) &gt;= (r); (i)--)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt, val;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt, head[N], dis[N], siz[N], son[N], dep[N], top[N], tot[N], ans[N], c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt] = (edge)&#123;v, head[u], w&#125;, head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>; <span class="keyword">int</span> f=<span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) f |= (c == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span>+(c ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">if</span>(f) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(T &amp;x, <span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">short</span> st[<span class="number">30</span>], tp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> st[++tp] = x % <span class="number">10</span>, x /= <span class="number">10</span>; <span class="keyword">while</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(tp) <span class="built_in">putchar</span>(st[tp--] | <span class="number">48</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, res;</span><br><span class="line"><span class="keyword">int</span> maxn, minn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    siz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">        <span class="keyword">if</span> (siz[v] &gt; siz[son[u]]) son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> val, <span class="keyword">int</span> sonu)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="number">1</span>) &#123;</span><br><span class="line">        tot[c[u]] ++;</span><br><span class="line">        <span class="keyword">if</span> (tot[c[u]] &gt; maxn) maxn = tot[c[u]], res = c[u]; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tot[c[u]] == maxn) res += c[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> tot[c[u]]--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == f || v == sonu) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">calc</span>(v, u, val, sonu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dsu</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> val)</span> </span>&#123;    <span class="comment">//val为1表示是重儿子,不会进行二次递归,val为0表示是轻儿子,第一次统计信息并删除,第二次统计信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == f || v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dsu</span>(v, u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) <span class="built_in">dsu</span>(son[u], u, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">calc</span>(u, f, <span class="number">1</span>, son[u]);</span><br><span class="line">    ans[u] = res;</span><br><span class="line">    <span class="keyword">if</span> (!val) <span class="built_in">calc</span>(u, f, <span class="number">-1</span>, <span class="number">0</span>), maxn = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">rep</span> (i, <span class="number">1</span>, n) <span class="built_in">read</span>(c[i]);</span><br><span class="line">    <span class="built_in">rep</span> (i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">read</span>(u), <span class="built_in">read</span>(v);</span><br><span class="line">        <span class="built_in">add</span>(u, v, <span class="number">0</span>), <span class="built_in">add</span>(v, u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dsu</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">rep</span> (i, <span class="number">1</span>, n) <span class="built_in">write</span>(ans[i], <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/merge_sort/</url>
    <content><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="核心思想：分治"><a href="#核心思想：分治" class="headerlink" title="核心思想：分治"></a>核心思想：分治</h2><h5 id="①递归排序-left-right-此时前后两边都有序了"><a href="#①递归排序-left-right-此时前后两边都有序了" class="headerlink" title="①递归排序 $left$     $right$ 此时前后两边都有序了"></a>①递归排序 $left$     $right$ 此时前后两边都有序了</h5><h5 id="②归并排序-将以拥有的放到一个新数组中"><a href="#②归并排序-将以拥有的放到一个新数组中" class="headerlink" title="②归并排序  将以拥有的放到一个新数组中"></a>②归并排序  将以拥有的放到一个新数组中</h5><hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> q[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q,l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;=q[j]) tmp[k++]=q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++]=q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) tmp[k++]=q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) tmp[k++]=q[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) q[i]=tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/quick_sort/</url>
    <content><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h3 id="核心思想：分治"><a href="#核心思想：分治" class="headerlink" title="核心思想：分治"></a>核心思想：分治</h3><h5 id="①确定分界点：X可以取q-l-q-l-r-gt-gt-1-q-r"><a href="#①确定分界点：X可以取q-l-q-l-r-gt-gt-1-q-r" class="headerlink" title="①确定分界点：X可以取q[l],q[(l+r)&gt;&gt;1],q[r]"></a>①确定分界点：X可以取q[l],q[(l+r)&gt;&gt;1],q[r]</h5><h5 id="②调整范围，把小于x的放在左边，大于x的放在右边（重点）"><a href="#②调整范围，把小于x的放在左边，大于x的放在右边（重点）" class="headerlink" title="②调整范围，把小于x的放在左边，大于x的放在右边（重点）"></a>②调整范围，把小于x的放在左边，大于x的放在右边（重点）</h5><h5 id="③递归处理左右两段"><a href="#③递归处理左右两段" class="headerlink" title="③递归处理左右两段"></a>③递归处理左右两段</h5><hr>
<h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>①开两个额外的数组</p>
<p>②q[ l~r ]</p>
<p>(1)q[i]&lt;=x  x-&gt;a[]  (2)q[i]&gt;x   x-&gt;b[];</p>
<hr>
<h5 id="方法二（常用）："><a href="#方法二（常用）：" class="headerlink" title="方法二（常用）："></a>方法二（常用）：</h5><p>①用两个指针i，j</p>
<p>②当i&gt;=x 时移动j，然后找到符合条件的j，交换i，j,最后处理剩余的</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> x=q[l];</span><br><span class="line">    <span class="keyword">int</span> i=l<span class="number">-1</span>,j=r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划的一点理解</title>
    <url>/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>动态规划的本质不在于是递推或是递归，也不需要纠结是不是内存换时间。</p>
<p>理解动态规划并不需要数学公式介入，只是完全解释清楚需要点篇幅…首先需要明白哪些问题不是动态规划可以解决的，才能明白为神马需要动态规划。不过好处时顺便也就搞明白了递推贪心搜索和动规之间有什么关系，以及帮助那些总是把动规当成搜索解的同学建立动规的思路。</p>
<p>动态规划是对于<strong>某一类问题</strong>的解决方法！！重点在于如何鉴定<strong>某一类问题</strong>是动态规划可解的而不是纠结解决方法是递归还是递推！</p>
<p>怎么鉴定dp可解的一类问题需要从计算机是怎么工作的说起…计算机的本质是一个状态机，内存里存储的所有数据构成了当前的状态，CPU只能利用当前的状态计算出下一个状态（不要纠结硬盘之类的外部存储，就算考虑他们也只是扩大了状态的存储容量而已，并不能改变下一个状态只能从当前状态计算出来这一条铁律）</p>
<p>当你企图使用计算机解决一个问题是，其实就是在思考如何将这个问题表达成状态（用哪些变量存储哪些数据）以及如何在状态中转移（怎样根据一些变量计算出另一些变量）。所以所谓的空间复杂度就是为了支持你的计算所必需存储的状态最多有多少，所谓时间复杂度就是从初始状态到达最终状态中间需要多少步！</p>
<p>太抽象了还是举个例子吧：</p>
<p>比如说我想计算第100个斐波那契数，每一个斐波那契数就是这个问题的一个状态，每求一个新数字只需要之前的两个状态。所以同一个时刻，最多只需要保存两个状态，空间复杂度就是常数；每计算一个新状态所需要的时间也是常数且状态是线性递增的，所以时间复杂度也是线性的。</p>
<p>上面这种状态计算很直接，只需要依照固定的模式从旧状态计算出新状态就行（a[i]=a[i-1]+a[i-2]），不需要考虑是不是需要更多的状态，也不需要选择哪些旧状态来计算新状态。对于这样的解法，我们叫递推。</p>
<p>斐波那契那个例子过于简单，以至于让人忽视了阶段的概念，所谓阶段是指随着问题的解决，在同一个时刻可能会得到的不同状态的集合。斐波那契数列中，每一步会计算得到一个新数字，所以每个阶段只有一个状态。想象另外一个问题情景，假如把你放在一个围棋棋盘上的某一点，你每一步只能走一格，因为你可以东南西北随便走，所以你当你同样走四步可能会处于很多个不同的位置。从头开始走了几步就是第几个阶段，走了n步可能处于的位置称为一个状态，走了这n步所有可能到达的位置的集合就是这个阶段下所有可能的状态。</p>
<p>现在问题来了，有了阶段之后，计算新状态可能会遇到各种奇葩的情况，针对不同的情况，就需要不同的算法，下面就分情况来说明一下：</p>
<p>假如问题有n个阶段，每个阶段都有多个状态，不同阶段的状态数不必相同，一个阶段的一个状态可以得到下个阶段的所有状态中的几个。那我们要计算出最终阶段的状态数自然要经历之前每个阶段的某些状态。</p>
<p>好消息是，有时候我们并不需要真的计算所有状态，比如这样一个弱智的棋盘问题：从棋盘的左上角到达右下角最短需要几步。答案很显然，用这样一个弱智的问题是为了帮助我们理解阶段和状态。某个阶段确实可以有多个状态，正如这个问题中走n步可以走到很多位置一样。但是同样n步中，有哪些位置可以让我们在第n+1步中走的最远呢？没错，正是第n步中走的最远的位置。换成一句熟悉话叫做“下一步最优是从当前最优得到的”。所以为了计算最终的最优值，只需要存储每一步的最优值即可，解决符合这种性质的问题的算法就叫贪心。如果只看最优状态之间的计算过程是不是和斐波那契数列的计算很像？所以计算的方法是递推。</p>
<p>既然问题都是可以划分成阶段和状态的。这样一来我们一下子解决了一大类问题：一个阶段的最优可以由前一个阶段的最优得到。</p>
<p>如果一个阶段的最优无法用前一个阶段的最优得到呢？</p>
<p>什么你说只需要之前两个阶段就可以得到当前最优？那跟只用之前一个阶段并没有本质区别。最麻烦的情况在于你需要之前所有的情况才行。</p>
<p>再来一个迷宫的例子。在计算从起点到终点的最短路线时，你不能只保存当前阶段的状态，因为题目要求你最短，所以你必须知道之前走过的所有位置。因为即便你当前再的位置不变，之前的路线不同会影响你的之后走的路线。这时你需要保存的是之前每个阶段所经历的那个状态，根据这些信息才能计算出下一个状态！</p>
<p>每个阶段的状态或许不多，但是每个状态都可以转移到下一阶段的多个状态，所以解的复杂度就是指数的，因此时间复杂度也是指数的。哦哦，刚刚提到的之前的路线会影响到下一步的选择，这个令人不开心的情况就叫做有后效性。</p>
<p>刚刚的情况实在太普遍，解决方法实在太暴力，有没有哪些情况可以避免如此的暴力呢？</p>
<p>契机就在于后效性。</p>
<p>有一类问题，看似需要之前所有的状态，其实不用。不妨也是拿最长上升子序列的例子来说明为什么他不必需要暴力搜索，进而引出动态规划的思路。</p>
<p>假装我们年幼无知想用搜索去寻找最长上升子序列。怎么搜索呢？需要从头到尾依次枚举是否选择当前的数字，每选定一个数字就要去看看是不是满足“上升”的性质，这里第i个阶段就是去思考是否要选择第i个数，第i个阶段有两个状态，分别是选和不选。哈哈，依稀出现了刚刚迷宫找路的影子！咦慢着，每次当我决定要选择当前数字的时候，只需要和之前选定的一个数字比较就行了！这是和之前迷宫问题的本质不同！这就可以纵容我们不需要记录之前所有的状态啊！既然我们的选择已经不受之前状态的组合的影响了，那时间复杂度自然也不是指数的了啊！虽然我们不在乎某序列之前都是什么元素，但我们还是需要这个序列的长度的。所以我们只需要记录以某个元素结尾的LIS长度就好！因此第i个阶段的最优解只是由前i-1个阶段的最优解得到的，然后就得到了DP方程</p>
<p>$f_i=max(f_j+1,j_i)$  $j∈([1,i) ∩ a_j&lt;a_i)$</p>
<p>所以一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！</p>
<p>每个阶段只有一个状态-&gt;递推；<br>每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心；<br>每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索；<br>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。</p>
<blockquote>
<p>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到</p>
</blockquote>
<p>这个性质叫做最优子结构；</p>
<blockquote>
<p>而不管之前这个状态是如何得到的</p>
</blockquote>
<p>这个性质叫做无后效性。</p>
<p>另：其实动态规划中的最优状态的说法容易产生误导，以为只需要计算最优状态就好，LIS问题确实如此，转移时只用到了每个阶段“选”的状态。但实际上有的问题往往需要对每个阶段的所有状态都算出一个最优值，然后根据这些最优值再来找最优状态。比如背包问题就需要对前i个包（阶段）容量为j时（状态）计算出最大价值。然后在最后一个阶段中的所有状态种找到最优值。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>区间DP</title>
    <url>/%E5%8C%BA%E9%97%B4DP/</url>
    <content><![CDATA[<h1 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h1><h2 id="什么是区间-DP"><a href="#什么是区间-DP" class="headerlink" title="什么是区间 DP"></a>什么是区间 DP</h2><p>区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。令状态$f_{i,j}$表示将下标位置$i$到$j$的所有元素合并能获得的价值的最大值，那么 ，$max(f_{i,k}+f_{k+1,j}+cost)$为将这两组元素合并起来的代价。</p>
<p>区间 DP 的特点：</p>
<p><strong>合并</strong>：即将两个或多个部分进行整合，当然也可以反过来；</p>
<p><strong>特征</strong>：能将问题分解为能两两合并的形式；</p>
<p><strong>求解</strong>：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h4 id="1-迭代式"><a href="#1-迭代式" class="headerlink" title="1.迭代式"></a>1.迭代式</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=n-len+<span class="number">1</span>;l++)&#123;</span><br><span class="line">        <span class="keyword">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=l;k&lt;r;k++)&#123;</span><br><span class="line">            f[l][r]=max/<span class="built_in">min</span> (f[l][r],f[l][k]+f[k+<span class="number">1</span>][r]+a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[<span class="number">1</span>][n]</span><br></pre></td></tr></table></figure>
<h4 id="2-记忆化搜索"><a href="#2-记忆化搜索" class="headerlink" title="2.记忆化搜索"></a>2.记忆化搜索</h4><h2 id="破环为链"><a href="#破环为链" class="headerlink" title="破环为链"></a>破环为链</h2><p>详情见<a href="https://www.luogu.com.cn/problem/P1880">石子合并</a></p>
<p>先设sum[i]表示从1~i的前缀和</p>
<p>如果石堆排成一排</p>
<p>那么显然有转移方程</p>
<script type="math/tex; mode=display">
f_{i,j}=max(f_{i,j},f_{i,k}+f_{k+1,j}+sum[r]-sum[l-1])</script><p>但是我们观察这道题可以发现，由于这些石堆不是一个圈，而是一条链，那么我们考虑：</p>
<p>1.朴素做法：让每一个点都成为第一个点，然后逐次试一试 (时间复杂度：$O(N^4)$)</p>
<p>2.破坏为链：先将这个链拆开，然后复制一下这条链，首连尾粘贴到链的一端</p>
<p>就大概长成这样（画的好丑啊</p>
<p>时间复杂度：$O(n^3)$</p>
<p>高精度区间DP</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针</title>
    <url>/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><p>核心：将暴力做法优化到O(n)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//朴素做法O(n^2)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(j,i)) 					res=<span class="built_in">max</span>(res,j-i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针算法O(n)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=i&amp;&amp;<span class="built_in">check</span>(j,i)) j++;</span><br><span class="line">    res=<span class="built_in">max</span>(res,j-i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1 2 2 3 5</p>
<p>len 1 2    1 2 3<br>    i 1 1 1 3 3 3<br>    j 1 2 3 3 4 5</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    s[a[i]]++;</span><br><span class="line">    <span class="keyword">while</span>(s[a[i]]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        s[a[j++]]--;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,i-j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>四边形不等式优化</title>
    <url>/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="四边形不等式"><a href="#四边形不等式" class="headerlink" title="四边形不等式"></a>四边形不等式</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对于形如</p>
<script type="math/tex; mode=display">
f_{i,j}=min(f_{i,k}+f_{k+1,j})+s[i][j];</script><p>的式子，</p>
<p>若s满足四边形不等式，则</p>
<script type="math/tex; mode=display">
w_{i,j}+w_{i+1,j+1}<w_{i,j+1}+w_{i+1,j}</script><script type="math/tex; mode=display">
w_{i,j+1}+w_{i+1,j+2}<w_{i,j+2}+w_{i+1,j+1}</script><p>两边消掉即得</p>
<script type="math/tex; mode=display">
w_{i,j}+w_{i+1,j+2}<=w_{i,j+2}+w_{i+1,j}</script><p>图解四边形不等式：咕掉</p>
<h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><p>题意：略（此处要求最小得分）</p>
<script type="math/tex; mode=display">
dp_{i,j}=w_{i,j}+min(dp_{i,k}+dp_{k+1,j})</script><script type="math/tex; mode=display">
s_{i,j}=\sum^j_{k=i}a_k</script><p>此时</p>
<script type="math/tex; mode=display">
w_{i,j}+w_{i+1,j+1}<=w_{i+1,j}+w_{i,j+1}</script><p>而且因为w是区和    ∴此时应该是相等的   证毕（<del>太显然了吧</del>）</p>
<p>总结起来：</p>
<p>若满足1.凸四边形不等式：$w[a][c]+w[b][d]&lt;=w[b][c]+w[a][d]（a&lt;b&lt;c&lt;d）$<br>            2.区间包含关系单调: $w[b][c]&lt;=w[a][d]（a&lt;b&lt;c&lt;d）$</p>
<p>则满足</p>
<p>定理1：  如果w同时满足四边形不等式和决策单调性 ,则f也满足四边形不等式</p>
<p>定理2：  若f满足四边形不等式，则决策s满足 $s[i][j-1]&lt;=s[i][j]&lt;=s[i+1][j]$</p>
<p>定理3： w为凸当且仅当$w[i][j]+w[i+1][j+1]&lt;=w[i+1][j]+w[i][j+1]  $</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>图的存储和遍历模板</title>
    <url>/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BlackPink is the Revolution</span></span><br><span class="line"><span class="comment">light up the sky</span></span><br><span class="line"><span class="comment">Blackpink in your area</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); (i) &lt;= (b); ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); (i) &gt;= (b); --i) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> whlie while</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt, val;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt, head[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt] = (edge)&#123;v, head[u], w&#125;, head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++cnt] = (edge)&#123;v, head[u]&#125;, head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>; <span class="keyword">int</span> f=<span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) f |= (c == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + (c ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(T x, <span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">short</span> st[<span class="number">30</span>], tp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> st[++tp] = x % <span class="number">10</span>, x /= <span class="number">10</span>; <span class="keyword">while</span> (x);</span><br><span class="line">    <span class="keyword">while</span> (tp) <span class="built_in">putchar</span>(st[tp--] | <span class="number">48</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">bool</span> vis[N];</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(...) q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式全家桶</title>
    <url>/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%85%A8%E5%AE%B6%E6%A1%B6/</url>
    <content><![CDATA[<h1 id="多项式全家桶"><a href="#多项式全家桶" class="headerlink" title="多项式全家桶"></a>多项式全家桶</h1><h2 id="导数公式"><a href="#导数公式" class="headerlink" title="导数公式"></a>导数公式</h2><p>$(C)^{‘}=0$                                   $(x^\mu)’=\mu x^{\mu-1}$</p>
<p>$(a^x)’=a^x\ln x$ ( $a$ 为常数）    $(\sin x)’=\cos x$</p>
<p>$(\cos x)’=-\sin x$                    $(\tan x)’=\sec^2x$</p>
<p>$(\cot x)’=-\csc^2x$                  $(\sec x)’=\sec x \cot x$</p>
<p>$(\csc x)’=-\csc x\cot x$           $(\ln x)’=\dfrac{1}{x}$</p>
<p>$({\log_a}^x)’=\dfrac{1}{x\ln a}$                    $(e^x)’=e^x$</p>
<p>加减公式：</p>
<p>$(u\pm v)’=u’\pm v’$           $(Cu)’=Cu’$ （C是常数）</p>
<p>$(uv)’=u’v+uv’$            $(\dfrac{u}{v})’=(\dfrac{u’v-uv’}{v^2})$</p>
<h2 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h2><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>设$a,b$为实数，$i^2=-1$，形如$a+bi$的数叫复数，其中$i$被称为虚数单位，复数域是目前已知最大的域</p>
<p>在复平面中，$x$ 代表实数，$y$ 轴（除原点外的点）代表虚数，从原点$(0,0)$到$(a,b)$的向量表示复数$a+bi$</p>
<p>模长：从原点$(0,0)$到点$(a,b)$的距离，即$\sqrt{a^2+b^2}$</p>
<p>幅角：假设以逆时针为正方向，从x<em>x</em>轴正半轴到已知向量的转角的有向角叫做幅角</p>
<p>计算：平行四边形法则(其实就是分配律)，注意这里的$i^2$为-1：</p>
<p>几何定义：复数相乘，模长相乘，幅角相加<del>(至今我也没看懂)</del></p>
<p>$(a+bi)\times (c+di)=ac+bdi^2+bci+adi=ac-bd+(bc+ad)i$</p>
<h3 id="多项式表示法"><a href="#多项式表示法" class="headerlink" title="多项式表示法"></a>多项式表示法</h3><h4 id="系数表示法："><a href="#系数表示法：" class="headerlink" title="系数表示法："></a>系数表示法：</h4><p>设$A(x)$表示一个$x-1$次多项式</p>
<p>则$A(x)=\sum_{i=0}^{n} a_i * x^i$</p>
<p>例如：$A(3)=2+3\times x+x^2$</p>
<p>利用这种方法计算多项式乘法复杂度为$O(n^2)$</p>
<p>（第一个多项式中每个系数都需要与第二个多项式的每个系数相乘）</p>
<p>利用这种方法计算多项式乘法的时间复杂度为$O(n^2)$</p>
<h4 id="点值表示法"><a href="#点值表示法" class="headerlink" title="点值表示法"></a>点值表示法</h4><p>将 $n$ 互不相同的 $x$ 带入多项式，会得到 $n$ 个不同的取值 $y$</p>
<p>则该多项式被这 $n$ 个点 $(x_1,y_1),(x_2,y_2)\dots(x_n,y_n)$ 唯一确定</p>
<p>其中$y_i=\sum_{j=0}^{n-1} a_j\times x_i^j$</p>
<p>例如：上面的例子用点值表示法可以为$(0,2)~(1,5)~(2,12)$</p>
<p>利用这种方法计算多项式乘法的时间复杂度仍然为$O(n^2)$</p>
<p>可以发现，大整数乘法复杂度的瓶颈可能在“多项式转换成点值表示”这一步（以及其反向操作），只要完成这一步就可以$O(n)$求答案了。</p>
<h3 id="单位根"><a href="#单位根" class="headerlink" title="单位根"></a>单位根</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在后面我们默认 $n$ 为 2 的整数次幂</p>
<p>在复平面上，以原点为圆心，1为半径作圆，所得的圆叫单位圆。以圆点为起点，圆的$n$等分点为终点，做$n$个向量，设幅角为正且最小的向量对应的复数为$\omega_n$，称为$n$次单位根。</p>
<p>根据复数乘法的运算法则，其余$n-1$个复数为$\omega_n^2,\omega_n^3\ldots\omega_n^n$</p>
<p>就算他们的值，我们可以用欧拉公式：$\omega_{n}^{k}=\cos\ k <em>\dfrac{2\pi}{n}+i\sin k</em>\dfrac{2\pi}{n}$</p>
<p>单位根的幅角为周角的$\dfrac{1}{n}$</p>
<p>在代数中，若$z^n=1$，我们把$z$称为$n$次单位根</p>
<h4 id="单位根的性质与反演"><a href="#单位根的性质与反演" class="headerlink" title="单位根的性质与反演"></a>单位根的性质与反演</h4><p>单位根的<strong>性质</strong>：</p>
<ol>
<li><p>$\omega _n ^k =\cos~k\dfrac{2\pi}{n}+i\times \sin~k\dfrac{2\pi}{n}$</p>
</li>
<li><p>$\omega _{2n}^{2k}=\omega _n^k$</p>
</li>
<li>$\omega_n^{k+\frac{n}{2}}=-\omega _n^k$</li>
<li>$\omega_n^0=\omega _n^n=1$</li>
</ol>
<p>第二条的证明：</p>
<p>$\omega ^{2k}_{2n}=\cos ~2k\dfrac{2\pi}{2n}+i\sin2k\dfrac{2\pi}{2n}$</p>
<p>约分后就和原来一样了</p>
<p>第三条同上，约分即可</p>
<p>单位根<strong>反演</strong>：</p>
<script type="math/tex; mode=display">
\forall k,[n\mid k]=\dfrac{1}{n}\sum_{i=0}^{n-1}w_n^{ik}\dots①</script><p>证明：</p>
<p>当$~k\mid n$ 时：由 $\omega_n^0=\omega_n^n~~~$得:$\omega_n^{ik}=1$故原式等于1</p>
<p>当 $k\nmid n$ 时：原式乘上$\omega_n^k$可化成</p>
<script type="math/tex; mode=display">
\dfrac{1}{n}\sum_{i=1}^{n}w_n^{ik}\dots②</script><p>②减①得：</p>
<script type="math/tex; mode=display">
\dfrac{1}{n}\dfrac{\omega_{n}^{nk}-\omega_n^0}{\omega_n^k-1}</script><p>易得上式为0</p>
<h3 id="complex"><a href="#complex" class="headerlink" title="complex"></a>complex</h3><p>C++的STL提供了复数模板！<br>头文件：<code>#include &lt;complex&gt;</code><br>定义： <code>complex&lt;double&gt; x;</code><br>运算：直接使用加减乘除</p>
<h3 id="快速傅里叶变换（FFT）"><a href="#快速傅里叶变换（FFT）" class="headerlink" title="快速傅里叶变换（FFT）"></a>快速傅里叶变换（FFT）</h3><h4 id="为什么要使用单位根作为-x-代入"><a href="#为什么要使用单位根作为-x-代入" class="headerlink" title="为什么要使用单位根作为$x$代入"></a>为什么要使用单位根作为$x$代入</h4><p>规定我们带入的点值为$n$个单位根</p>
<p>设$(y_0,y_1,y_2\dots y_{n-1})$为多项式$A(x)$的离散傅里叶变换（即把$\omega_n^0,\omega_n^1\dots\omega_n^{n-1}$代入上式后的结果）</p>
<p>我们再设一个多项式$B(x)$其各位系数为上述的$y$</p>
<p>现在，我们把上述单位根的倒数，即$\omega_n^{-1},\omega_n^{-2}\dots\omega_n^{1-n}$代入$B(x)$得$(z_0,z_1\dots z_{n-1})$，那么有</p>
<script type="math/tex; mode=display">
\begin{eqnarray}
z_k&=&\sum_{i=0}^{n-1}y_i(\omega_n^{-k})^i\\
&=&\sum_{i=0}^{n-1}(\sum_{j=0}^{n-1}a_j(\omega_n^i)^j)(\omega_n^{-k})^i
\\&=&\sum_{i=0}^{n-1}a_j(\sum_{j=0}^{n-1}(\omega_n^{j-k})^i)
\end{eqnarray}</script><p>最下面括号里的式子$\sum_{j=0}^{n-1}(\omega_n^{j-k})^i$显然是能求的</p>
<p>当 $k=j$ 时，该式为$n$</p>
<p>当 $k\ne j$ 时</p>
<p>通过等比数列求和可以得出</p>
<script type="math/tex; mode=display">
\dfrac{(\omega_n^{j-k})^n-1}{\omega_n^{j-k}-1}=\dfrac{1-1}{\omega_n^{j-k}-1}=0</script><p>所以我们有</p>
<script type="math/tex; mode=display">
z_k=na_k</script><p>因此我们可以发现：</p>
<p>把多项式$A(x)$的离散傅里叶变换结果作为另一个多项式$B(x)$的系数，取单位根的倒数即$\omega ^0_n,\omega ^{−1}_n,\omega ^{−2}_n,…,\omega ^{-(n−1)}_n$作为$x$代入$B(x)$，得到的每个数再除以$n$，得到的就是$A(x)$的各项系数</p>
<h4 id="快速傅里叶变换的数学证明"><a href="#快速傅里叶变换的数学证明" class="headerlink" title="快速傅里叶变换的数学证明"></a>快速傅里叶变换的数学证明</h4><p>我们考虑把一个普通的多项式按奇偶性分类，有：</p>
<script type="math/tex; mode=display">
A(x)=(a_0+a_2\times x^2+a_4\times x^4+⋯+a_{n−2}\times x^{n−2})+(a_1\times x+a_3\times x^3+a_5\times x^5+⋯+a_{n−1}\times x^{n−1})</script><p>所以我们设成两个多项式：</p>
<p>$A_1(x)=a_0+a_2x+a_4x^2+⋯+a_{n−2}x^{\frac{n}{2}-1}$</p>
<p>$A_2(x)=a_1+a_3x+a_5x^2+⋯+a_{n−1}x^{\frac{n}{2}-1}$</p>
<p>因此$A(x)=A_1(x^2)+xA_2(x^2)$</p>
<p>假设当前$k&lt;\frac{n}{2}$，现再我们要代入$x=\omega_n^k$</p>
<script type="math/tex; mode=display">
\begin{eqnarray}
A(\omega_n^k)&=&A_1(\omega_n^{2k})+\omega_n^kA_2(\omega^{2k}_n)
\\&=&A1(\omega_{\frac{n}{2}}^{k})+\omega_n^kA_2(\omega^k_{\frac{n}{2}})
\end{eqnarray}</script><p>我们再代入$x=\omega_n^{k+\frac{n}{2}}$</p>
<script type="math/tex; mode=display">
\begin{eqnarray}
A(\omega_n^{k+\frac{n}{2}})&=&A_1(\omega_n^{2k+n})+\omega_n^{k+\frac{n}{2}}A_2(\omega^{2k+n}_n)
\\&=&A1(\omega_{\frac{n}{2}}^{k})-\omega_n^kA_2(\omega^k_{\frac{n}{2}})
\end{eqnarray}</script><p>因此，只要我们求出$A_1(x)$和$A_2(x)$分别在$\omega_{\frac{n}{2}}^0,\omega_{\frac{n}{2}}^1,\omega_{\frac{n}{2}}^2$等的点值表示，就可以$O(n)$的求出$A(x)$的点值表示了。分治的边界是$n=1$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">2</span>*<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c=<span class="built_in">getchar</span>();<span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">    <span class="built_in">complex</span> (<span class="keyword">double</span> xx=<span class="number">0</span>,<span class="keyword">double</span> yy=<span class="number">0</span>)&#123;x=xx,y=yy;&#125;</span><br><span class="line">&#125;a[MAXN],b[MAXN];</span><br><span class="line">complex <span class="keyword">operator</span> + (complex a,complex b)&#123; <span class="keyword">return</span> <span class="built_in">complex</span>(a.x+b.x , a.y+b.y);&#125;</span><br><span class="line">complex <span class="keyword">operator</span> - (complex a,complex b)&#123; <span class="keyword">return</span> <span class="built_in">complex</span>(a.x-b.x , a.y-b.y);&#125;</span><br><span class="line">complex <span class="keyword">operator</span> * (complex a,complex b)&#123; <span class="keyword">return</span> <span class="built_in">complex</span>(a.x*b.x-a.y*b.y , a.x*b.y+a.y*b.x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fast_fast_tle</span><span class="params">(<span class="keyword">int</span> len,complex *a,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    complex a1[len&gt;&gt;<span class="number">1</span>],a2[len&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len;i+=<span class="number">2</span>) a1[i&gt;&gt;<span class="number">1</span>]=a[i],a2[i&gt;&gt;<span class="number">1</span>]=a[i+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">fast_fast_tle</span>(len&gt;&gt;<span class="number">1</span>,a1,type);</span><br><span class="line">    <span class="built_in">fast_fast_tle</span>(len&gt;&gt;<span class="number">1</span>,a2,type);</span><br><span class="line">    complex Wn=<span class="built_in">complex</span>(<span class="built_in">cos</span>(<span class="number">2.0</span>*Pi/len),type*<span class="built_in">sin</span>(<span class="number">2.0</span>*Pi/len)),w=<span class="built_in">complex</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(len&gt;&gt;<span class="number">1</span>);i++,w=w*Wn)</span><br><span class="line">        a[i]=a1[i]+w*a2[i],</span><br><span class="line">        a[i+(len&gt;&gt;<span class="number">1</span>)]=a1[i]-w*a2[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N=<span class="built_in">read</span>(),M=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N;i++) a[i].x=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=M;i++) b[i].x=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(len&lt;=N+M) len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fast_fast_tle</span>(len,a,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fast_fast_tle</span>(len,b,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//type为1表示从系数变为点值</span></span><br><span class="line">    <span class="comment">//-1表示从点值变为系数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len;i++) a[i]=a[i]*b[i];</span><br><span class="line">    <span class="built_in">fast_fast_tle</span>(len,a,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N+M;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,(<span class="keyword">int</span>)(a[i].x/len+<span class="number">0.5</span>));<span class="comment">//按照我们推倒的公式，这里还要除以n </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化FFT"><a href="#优化FFT" class="headerlink" title="优化FFT"></a>优化FFT</h3><h4 id="递归优化"><a href="#递归优化" class="headerlink" title="递归优化"></a>递归优化</h4><p>在进行$\text{fft}$时，我们要把各个系数不断分组并放到两侧，那么一个系数原来的位置和最终的位置有什么规律呢？</p>
<p>初始位置：0 1 2 3 4 5 6 7<br>第一轮后：0 2 4 6|1 3 5 7<br>第二轮后：0 4|2 6|1 5|3 7<br>第三轮后：0|4|2|6|1|5|3|7</p>
<p>用|隔开各组数据</p>
<p>我们把二进制拉出来，发现一个位置a上的数，最后所在的位置是a二进制翻转得到的数</p>
<p>那么我们可以据此写出非递归版本$\text{fft}$：先把每个数放到最后的位置上，然后不断向上还原，同时求出点值表示。</p>
<h4 id="蝴蝶操作"><a href="#蝴蝶操作" class="headerlink" title="蝴蝶操作"></a>蝴蝶操作</h4><p>貌似也没啥，就是把东西先存上再用，感觉直接看模板就懂了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">4e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">int</span> f=<span class="number">0</span>;<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>()) f |= c==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(;<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>()) x=x*<span class="number">10</span>+(c^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">if</span>(f) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(T x,<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">short</span> st[<span class="number">30</span>],tp;</span><br><span class="line">    <span class="keyword">do</span> st[++tp]=x%<span class="number">10</span>,x/=<span class="number">10</span>; <span class="keyword">while</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(tp) <span class="built_in">putchar</span>(st[tp--] | <span class="number">48</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rev[N],b;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cp</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">    <span class="built_in">cp</span>()&#123;x=<span class="number">0</span>,y=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">cp</span>(<span class="keyword">double</span> xx,<span class="keyword">double</span> yy)&#123;x=xx,y=yy;&#125;</span><br><span class="line">&#125;f[N],g[N],ans[N];</span><br><span class="line">cp <span class="keyword">operator</span> + (cp a,cp b)&#123;<span class="keyword">return</span> <span class="built_in">cp</span>(a.x+b.x,a.y+b.y);&#125;</span><br><span class="line">cp <span class="keyword">operator</span> - (cp a,cp b)&#123;<span class="keyword">return</span> <span class="built_in">cp</span>(a.x-b.x,a.y-b.y);&#125;</span><br><span class="line">cp <span class="keyword">operator</span> * (cp a,cp b)&#123;<span class="keyword">return</span> <span class="built_in">cp</span>(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;                                                                                                  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> n,cp *a,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(a[i],a[rev[i]]);<span class="comment">//蝴蝶操作，说实话，我都没看懂哪里来的蝴蝶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;n;len&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function">cp <span class="title">w1</span><span class="params">(cos(pi/len),sin(pi/len)*type)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=(len&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="function">cp <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)&#123;</span><br><span class="line">                cp x=a[i+j],y=w*a[i+j+len];</span><br><span class="line">                a[i+j]=x+y; a[i+j+len]=x-y;</span><br><span class="line">                w=w*w1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,k=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n),<span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) <span class="built_in">read</span>(f[i].x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++) <span class="built_in">read</span>(g[i].x);</span><br><span class="line">    <span class="keyword">while</span>(k&lt;=n+m) k&lt;&lt;=<span class="number">1</span>,b++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++)rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(b<span class="number">-1</span>));<span class="comment">//rev[i]表示i翻转后的值 一个简单DP</span></span><br><span class="line">    <span class="built_in">FFT</span>(k,f,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FFT</span>(k,g,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++) ans[i]=f[i]*g[i];</span><br><span class="line">    <span class="built_in">FFT</span>(k,ans,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+m;i++) <span class="built_in">write</span>((<span class="keyword">int</span>)(ans[i].x/k+<span class="number">0.5</span>),<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h2><h3 id="阶"><a href="#阶" class="headerlink" title="阶"></a>阶</h3><p>设 $r,n$ 是互素的整数， $r \not = 0$ ，$n&gt;0$ ，使得 $r^x\equiv 1 \pmod n$ 成立的<strong>最小正整数</strong></p>
<p>$x$ 称为 $r$ 模 $x$ 的<strong>阶</strong>，标为 $\text{ord}_n r$  </p>
<h3 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h3><p>如果 $r,n$ 都是互素的正整数，当 $\text{ord}_nr=\varphi(n)$ 时，称 $r$ 是模 $n$ 的原根，即 $r$ 是 $n$ 的原根</p>
<p>我们令 $n$ 为大于 $1$ 的 $2$ 的幂，$p$ 为素数且 $n \mid (p-1)$，$g$ 为 $p$ 的一个原根</p>
<p>我们设</p>
<script type="math/tex; mode=display">
g_n=g^{\frac{p-1}{n}}</script><p>所以</p>
<script type="math/tex; mode=display">
\begin{eqnarray}
g_n^n&=&g^{n·\frac{p-1}{n}}=g^{p-1}
\\g_n^{\frac{n}{2}}&=&g^{\frac{g-1}{2}}
\\g_{an}^{ak}&=&g^{\frac{ak(p-1)}{an}}=g^{\frac{k(p-1)}{n}}=g_n^k
\end{eqnarray}</script><p>我们发现，原根包含着单位根的所有性质，所以我们就可以用原根代替单位根</p>
<p>最大优点：保持精度不变</p>
<p>特殊记忆：998244353的原根是3</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">4e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G=<span class="number">3</span>,invG=<span class="number">332748118</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">int</span> f=<span class="number">0</span>;<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>()) f |= c==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(;<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>()) x=x*<span class="number">10</span>+(c^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">if</span>(f) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(T x,<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">short</span> st[<span class="number">30</span>],tp;</span><br><span class="line">    <span class="keyword">do</span> st[++tp]=x%<span class="number">10</span>,x/=<span class="number">10</span>; <span class="keyword">while</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(tp) <span class="built_in">putchar</span>(st[tp--] | <span class="number">48</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k)&#123;</span><br><span class="line">		<span class="keyword">if</span>(k&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">		x=x*x%mod;</span><br><span class="line">		k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> rev[N],b;</span><br><span class="line"><span class="keyword">int</span> f[N],g[N],ans[N];                                                                                        </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> *a,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;n;len&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> w1=<span class="built_in">power</span>(type==<span class="number">1</span>?G:invG,(mod<span class="number">-1</span>)/(len&lt;&lt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=(len&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">int</span> w=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x=a[i+j]%mod,y=w*a[i+j+len]%mod;</span><br><span class="line">                a[i+j]=(x+y)%mod; a[i+j+len]=(((x-y)%mod)+mod)%mod;</span><br><span class="line">                w=w*w1%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> ny=<span class="built_in">power</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i]=(a[i]*ny+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,k=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// system(&quot;fc 1.out 1.ans&quot;);</span></span><br><span class="line">	<span class="comment">// freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="comment">// freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">read</span>(n),<span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) <span class="built_in">read</span>(f[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++) <span class="built_in">read</span>(g[i]);</span><br><span class="line">    <span class="keyword">while</span>(k&lt;=n+m) k&lt;&lt;=<span class="number">1</span>,b++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++)rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(b<span class="number">-1</span>));</span><br><span class="line">    <span class="built_in">FFT</span>(k,f,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FFT</span>(k,g,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++) ans[i]=f[i]*g[i]%mod;</span><br><span class="line">    <span class="built_in">FFT</span>(k,ans,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+m;i++) <span class="built_in">write</span>(ans[i],<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多项式乘法逆"><a href="#多项式乘法逆" class="headerlink" title="多项式乘法逆"></a>多项式乘法逆</h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个多项式 $F(x)$ ，请求出一个多项式 $G(x)$， 满足 $F(x)*G(x)\equiv 1\pmod{x^n}$。系数对 $998244353$ 取模。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>首先，若 $x$ 只有 $1$ 项时，我们的 $G(x)$ 就是 $x$ 的逆元，不然的话，我们就可以递归求解</p>
<p>我们假设当前已知：</p>
<script type="math/tex; mode=display">
F(x)*H(x)\equiv1\pmod{x^{\lfloor \frac{n}{2} \rfloor}}</script><p>由于 </p>
<script type="math/tex; mode=display">
F(x)*G(x)\equiv1\pmod {x^n}</script><p>显然：</p>
<script type="math/tex; mode=display">
F(x)*G(x)\equiv1\pmod {x^{\lfloor \frac{n}{2} \rfloor}}</script><p>两式相减，我们就可以得到：</p>
<script type="math/tex; mode=display">
F(x)*(G(x)-H(x))\equiv0\pmod{x^{\lfloor \frac{n}{2} \rfloor}}</script><p>左右同时把 $F(x)$ 去掉，则有</p>
<script type="math/tex; mode=display">
G(x)-H(x)\equiv0\pmod {x^{\lfloor\frac{n}{2}\rfloor}}</script><p>然后我们左右同时平方可以发现：</p>
<script type="math/tex; mode=display">
(G(x)-H(x))^2\equiv0\pmod{x^{n}}</script><p>拆开后有：</p>
<script type="math/tex; mode=display">
G^2(x)+H^2(x)-2G(x)H(x)\equiv 0\pmod {x^n}</script><p>再给两边乘上 $F(x)$，化简</p>
<script type="math/tex; mode=display">
F(x)*(G^2(x)+H^2(x)-2G(x)H(x))\equiv0\pmod{x^n}
\\G(x)-2H(x)+F(x)H^2(x)\equiv0 \pmod {x^n}
\\G(x)\equiv 2H(x)-F(x)H^2(x) \pmod {x^n}
\\G(x) \equiv H(x)\times (2-F(x)H(x)) \pmod {x^n}</script><p>我们发现已经用 $H(x)$ 和 $F(x)$ 来代替 $G(x)$ 了。</p>
<p>然后我们递归去找 $H(x)$ 就行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BlackPink is the Revolution</span></span><br><span class="line"><span class="comment">light up the sky</span></span><br><span class="line"><span class="comment">Blackpink in your area</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G=<span class="number">3</span>,invG=<span class="number">332748118</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> scan&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">        x=<span class="number">0</span>; <span class="keyword">char</span> c=<span class="built_in">getchar</span>(); <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c=<span class="built_in">getchar</span>()) f |= c==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c=<span class="built_in">getchar</span>()) x = x*<span class="number">10</span>+(c^<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">if</span>(f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T x,<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">short</span> st[<span class="number">30</span>],tp;</span><br><span class="line">        <span class="keyword">do</span> st[++tp] = x%<span class="number">10</span>, x/=<span class="number">10</span>; <span class="keyword">while</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(tp) <span class="built_in">putchar</span>(st[tp--] | <span class="number">48</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> scan;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> rev[N];</span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> H[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(y)&#123;</span><br><span class="line">		<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">		x=(x*x)%mod;</span><br><span class="line">		y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> *a,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;n;len&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> w1=<span class="built_in">qpow</span>(type==<span class="number">1</span> ? G : invG , (mod<span class="number">-1</span>)/(len&lt;&lt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=(len&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">int</span> w=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x=a[i+j]%mod,y=w*a[i+j+len]%mod;</span><br><span class="line">                a[i+j]=(x+y)%mod; a[i+j+len]=(((x-y)%mod)+mod)%mod;</span><br><span class="line">                w=w*w1%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> ny=<span class="built_in">qpow</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i]=(a[i]*ny+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetInv</span><span class="params">(<span class="keyword">int</span> *F,<span class="keyword">int</span> *G,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> G[<span class="number">0</span>]=<span class="built_in">qpow</span>(F[<span class="number">0</span>],mod<span class="number">-2</span>),<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GetInv</span>(F,G,(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> len=<span class="number">1</span>,L=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(len &lt; (n&lt;&lt;<span class="number">1</span>)) len&lt;&lt;=<span class="number">1</span>,L++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++) </span><br><span class="line">		rev[i]=(rev[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i&amp;<span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) H[i]=F[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;len;i++) H[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">NTT</span>(len,H,<span class="number">1</span>); <span class="built_in">NTT</span>(len,G,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">		G[i]=(((<span class="number">2ll</span>-G[i]*H[i]%mod)+mod)%mod*G[i]%mod);</span><br><span class="line">	<span class="built_in">NTT</span>(len,G,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;len;i++) G[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">read</span>(a[i]),a[i]=(a[i]+mod)%mod;</span><br><span class="line">	<span class="built_in">GetInv</span>(a,b,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">write</span>(b[i],<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多项式对数函数（多项式-ln）"><a href="#多项式对数函数（多项式-ln）" class="headerlink" title="多项式对数函数（多项式 ln）"></a>多项式对数函数（多项式 ln）</h2><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给出 $n-1$ 次多项式 $F(x)$ ，求一个 $\bmod x^n$ 下的多项式 $G(x)$，满足 $G(x)\equiv \ln F(x)\pmod {x^n}$ </p>
<p>首先，我们令 $f(x)=\ln(x)$</p>
<p>则原式可化为 $G(x)\equiv f(F(x))\pmod{x^n}$</p>
<p>我们对两边同时求导有：</p>
<p>$G’(x) \equiv f’(F(x))F’(x) \pmod {x^{n-1}}$</p>
<p>由于 $\ln’(x)=\dfrac{1}{x}$</p>
<p>$G’(x)\equiv\dfrac{F’(x)}{F(x)}  \pmod{x^{n-1}}$</p>
<p>那么我们此时再积回去，得到最终式子</p>
<script type="math/tex; mode=display">
G(x)=\int \dfrac{F'(x)}{F(x)} \pmod{x^n}</script><p> 至于积分和求导的求解，直接看就行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Direv</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> *B,<span class="keyword">int</span> len)</span></span>&#123; <span class="comment">//求导</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;++i) B[i<span class="number">-1</span>]=<span class="built_in">mul</span>(A[i],i); B[len<span class="number">-1</span>]=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inter</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> *B,<span class="keyword">int</span> len)</span></span>&#123; <span class="comment">//积分</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;++i) B[i]=<span class="built_in">mul</span>(A[i<span class="number">-1</span>],<span class="built_in">ksm</span>(i,P<span class="number">-2</span>)); B[<span class="number">0</span>]=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ln</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="built_in">Direv</span>(a,A,len),<span class="built_in">Inv</span>(a,B,len);<span class="keyword">int</span> l=len&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">NTT</span>(A,<span class="number">1</span>,l),<span class="built_in">NTT</span>(B,<span class="number">1</span>,l);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;++i) A[i]=<span class="built_in">mul</span>(A[i],B[i]);</span><br><span class="line">	<span class="built_in">NTT</span>(A,<span class="number">-1</span>,l),<span class="built_in">Inter</span>(A,b,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多项式开根"><a href="#多项式开根" class="headerlink" title="多项式开根"></a>多项式开根</h2><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个 $n-1$ 次多项式 $A(x)$ ，在 $\bmod x^n$ 意义下的多项式 $B(x)$ ，使得 $B^2(x)\equiv A(x) \pmod {x^n}$。若有多解，请取零次项系数较小的作为答案。</p>
<p>这个和上面那个差不多吧，顶多就是换个推导过程</p>
<p>假设我们已知：</p>
<script type="math/tex; mode=display">
H^2(x)\equiv F(x) \pmod {x^{\lceil \frac n 2 \rceil}}</script><p>易知：</p>
<script type="math/tex; mode=display">
G(x)\equiv H(x) \pmod {x^n}</script><p>我们继续推导可得：</p>
<script type="math/tex; mode=display">
G^2(x)-2H(x)\times G(x)+H^2(x)\equiv 0\pmod{x^n}\\
F(x)-2H(x)\times G(x)+H^2(x)\equiv 0 \pmod{x^n}\\
G(x)\equiv \dfrac{F(x)+H^2(x)}{2H(x)} \pmod {x^n}</script><p>由于题目要求0次项系数最小的最为答案，所以</p>
<script type="math/tex; mode=display">
G(x)=\dfrac{F(x)+H^2(x)}{2H(x)}</script><p>直接进行多项式求逆和NTT即可</p>
<p>边界：$B_0=\sqrt{A_0}=1$ (二次剩余)</p>
<h2 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h2><p>直接记公式吧：</p>
<script type="math/tex; mode=display">
G(F)=G\left(F_{0}\right)+G^{\prime}\left(F_{0}\right)\left(F-F_{0}\right)+G^{\prime \prime}\left(F_{0}\right)\left(F-F_{0}\right)^{2}+\cdots</script><h2 id="牛顿迭代"><a href="#牛顿迭代" class="headerlink" title="牛顿迭代"></a>牛顿迭代</h2><script type="math/tex; mode=display">
G(x_0)\equiv G_0(x) \dfrac{F(G_0(x))}{}</script><h2 id="多项式指数函数（多项式-exp）"><a href="#多项式指数函数（多项式-exp）" class="headerlink" title="多项式指数函数（多项式 exp）"></a>多项式指数函数（多项式 exp）</h2><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>给出 $n-1$ 次多项式 $A(x)$，求一个 $\bmod x^n$ 下的多项式 $B(x)$，满足 $B(x)\equiv e^{A(x)}$。系数对 $998244353$ 取模</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>对拍</title>
    <url>/%E5%AF%B9%E6%8B%8D/</url>
    <content><![CDATA[<h1 id="对拍"><a href="#对拍" class="headerlink" title="对拍"></a>对拍</h1><h2 id="随机数生成器"><a href="#随机数生成器" class="headerlink" title="随机数生成器"></a>随机数生成器</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));<span class="comment">//先加上这个</span></span><br><span class="line">    <span class="keyword">int</span> a=<span class="built_in">rand</span>();<span class="comment">//rand范围：0~32768 返回int，所以两个相乘可能会爆</span></span><br><span class="line"><span class="comment">//    可以进行取模操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对拍-1"><a href="#对拍-1" class="headerlink" title="对拍"></a>对拍</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;data.exe&quot;</span>);<span class="comment">//随机数</span></span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;baoli.exe&quot;</span>);<span class="comment">//暴力</span></span><br><span class="line">        <span class="keyword">double</span> a=<span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;ans.exe&quot;</span>);</span><br><span class="line">        <span class="keyword">double</span> b=<span class="built_in">clock</span>();<span class="comment">//返回毫秒</span></span><br><span class="line">        <span class="keyword">if</span>(b-a&gt;<span class="number">1000</span>) <span class="built_in">printf</span>(<span class="string">&quot;TLE\n&quot;</span>),<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);<span class="comment">//system(&quot;pause&quot;)输入任意键继续</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">system</span>(<span class="string">&quot;fc baoli.out candy.out&quot;</span>)) <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);<span class="comment">//当两者不一样时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>数位DP</title>
    <url>/%E6%95%B0%E4%BD%8DDP/</url>
    <content><![CDATA[<h2 id="数位DP"><a href="#数位DP" class="headerlink" title="数位DP"></a>数位DP</h2><h3 id="数位DP问题关键："><a href="#数位DP问题关键：" class="headerlink" title="数位DP问题关键："></a>数位DP问题关键：</h3><p>一般会问某一个区间里面满足某种性质的数的个数</p>
<p>技巧一：</p>
<p>$[x,y]$ = $f(y)-f(x-1)$ 类似前缀和的方式</p>
<p>技巧二：</p>
<p>以树的方式思考DP方式</p>
<h3 id="例题（持续更新）："><a href="#例题（持续更新）：" class="headerlink" title="例题（持续更新）："></a>例题（持续更新）：</h3><h4 id="度的数量"><a href="#度的数量" class="headerlink" title="度的数量"></a><a href="https://www.acwing.com/problem/content/1083/">度的数量</a></h4><p>题目描述：求给定区间 $[X,Y]$ 中满足下列条件的整数个数：这个数恰好等于 $K$ 个互不相等的 $B$ 的整数次幂之和。</p>
<p>数据范围：$x,y\le 2^{31}-1,k\le 20$ </p>
<p>首先我们要把N拆成B进制数</p>
<p>$N=\overline{a_{n-1}~a_{n-2}~a_{n-3}\dots a_0}$</p>
<ol>
<li><p>最高位填 $0\sim a_{n-1}-1$ ，显然这里后面的几位在 $0\sim B-1$ 之间可以随便填</p>
<p>如果当前位是1，那么我们有 $\binom B {k-1}$ 种填法</p>
<p>如果不是1，那么我们有 $\binom B k$ 种填法，总方案数就是两者相加</p>
</li>
<li><p>最高位填$a_{n-1}$ ，我们的下一位可以怎么填呢？</p>
<p>显然我们后面的一位是只能在 $0\sim a_{n-2}$ 里面填，这时我们可以继续按方案一继续讨论，知道填到 $a_0$ 为止</p>
</li>
</ol>
<p>当然，我们也可以直接用记忆化搜索来解决，就没有这么麻烦了，只需要考虑转移方程，然后写记忆化搜索即可~</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Edge&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> to,nxt,val;</span><br><span class="line">    &#125;e[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> head[N],cnt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        e[++cnt].val=w;</span><br><span class="line">        e[cnt].to=v;</span><br><span class="line">        e[cnt].nxt=head[u];</span><br><span class="line">        head[u]=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> scan&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">        x=<span class="number">0</span>; <span class="keyword">char</span> c=<span class="built_in">getchar</span>(); <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c=<span class="built_in">getchar</span>()) f |= c==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c=<span class="built_in">getchar</span>()) x = x*<span class="number">10</span>+(c^<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">if</span>(f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T x,<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">short</span> st[<span class="number">30</span>],tp;</span><br><span class="line">        <span class="keyword">do</span> st[++tp] = x%<span class="number">10</span>, x/=<span class="number">10</span>; <span class="keyword">while</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(tp) <span class="built_in">putchar</span>(st[tp--] | <span class="number">48</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> scan;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Edge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,f[N&lt;&lt;<span class="number">1</span>][N&lt;&lt;<span class="number">1</span>],C[N][N];</span><br><span class="line"><span class="keyword">int</span> l,r,k,b;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> pre,<span class="keyword">int</span> limit)</span></span>&#123;<span class="comment">//pos是枚举到哪一位，pre是目前已经有几个1了，limit是当前是否最高位的最大数</span></span><br><span class="line">    <span class="keyword">if</span>(pre&gt;k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!limit) f[pos][pre]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> pre==k;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; f[pos][pre]!=<span class="number">-1</span>) <span class="keyword">return</span> f[pos][pre];</span><br><span class="line">    <span class="keyword">int</span> up=limit ? a[pos] : b<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="built_in">min</span>(up,<span class="number">1</span>);i++)&#123;</span><br><span class="line">        res+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,pre+(i==<span class="number">1</span>),limit &amp;&amp; i==up);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit) f[pos][pre]=res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        a[++pos]=n%b;</span><br><span class="line">        n/=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(pos,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="built_in">read</span>(l),<span class="built_in">read</span>(r);</span><br><span class="line">    <span class="built_in">read</span>(k),<span class="built_in">read</span>(b);</span><br><span class="line">    <span class="built_in">write</span>(<span class="built_in">dp</span>(r)-<span class="built_in">dp</span>(l<span class="number">-1</span>),<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数字计数"><a href="#数字计数" class="headerlink" title="数字计数"></a><a href="https://www.luogu.com.cn/problem/P2602">数字计数</a></h4><p>题目描述：给定两个正整数 $a$ 和 $b$，求在 $[a,b]$ 中的所有整数中，每个数码(digit)各出现了多少次。</p>
<p>数据范围：$1\le a ,b\le10^{18}$</p>
<p>暴力的做法很显然了，而且这个题意和数据范围一看就很数位DP</p>
<p>所以我们直接考虑方程：$f_{i,j}$ 表示枚举到第 $i$ 位，已经选了 $j$ 个 $d$ 的方案数，其中 $d$ 是我们当前枚举的那个数</p>
<p>那么我们的转移也很显然：</p>
<script type="math/tex; mode=display">
f_{i,j}=\sum_{k=0}^{k<10} f_{i-1,j-[k==d]}</script><p>这个题我们在做的时候要有一个细节：如果我们枚举的这个数当前位是最高位且为0的话，这一位应该是没有贡献的，所以我们应该记忆化搜索时多加一个变量zero来限制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="number">3.141592653589793</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Edge&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> to,nxt,val;</span><br><span class="line">    &#125;e[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> head[N],cnt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        e[++cnt].val=w;</span><br><span class="line">        e[cnt].to=v;</span><br><span class="line">        e[cnt].nxt=head[u];</span><br><span class="line">        head[u]=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> scan&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">        x=<span class="number">0</span>; <span class="keyword">char</span> c=<span class="built_in">getchar</span>(); <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c=<span class="built_in">getchar</span>()) f |= c==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c=<span class="built_in">getchar</span>()) x = x*<span class="number">10</span>+(c^<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">if</span>(f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T x,<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">short</span> st[<span class="number">30</span>],tp;</span><br><span class="line">        <span class="keyword">do</span> st[++tp] = x%<span class="number">10</span>, x/=<span class="number">10</span>; <span class="keyword">while</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(tp) <span class="built_in">putchar</span>(st[tp--] | <span class="number">48</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> scan;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Edge;</span><br><span class="line"><span class="keyword">int</span> n,m,now;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1000</span>][<span class="number">1000</span>];<span class="comment">//f[i][j] 表示第i位上的数有j个k时，可能的方案数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> now,<span class="keyword">int</span> res,<span class="keyword">int</span> limit,<span class="keyword">int</span> zero)</span></span>&#123;<span class="comment">//zero是本题的点睛之笔</span></span><br><span class="line">	<span class="keyword">if</span>(!pos) <span class="keyword">return</span> res;</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; !zero &amp;&amp; f[pos][res]&gt;=<span class="number">0</span>) <span class="keyword">return</span> f[pos][res];</span><br><span class="line">	<span class="keyword">int</span> up=limit ? a[pos] : <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=up;i++) </span><br><span class="line">		<span class="keyword">if</span>(zero &amp;&amp; (i==<span class="number">0</span>)) ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,now,res,limit &amp;&amp; (i==a[pos]),<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,now,res+(i==now),limit &amp;&amp; (i==a[pos]),<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; !zero) f[pos][res]=ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> q,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(n)&#123;</span><br><span class="line">		a[++pos]=n%<span class="number">10</span>;</span><br><span class="line">		n/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">dfs</span>(pos,q,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="built_in">read</span>(n),<span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++) <span class="built_in">write</span>(<span class="built_in">dp</span>(i,m)-<span class="built_in">dp</span>(i,n<span class="number">-1</span>),<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="烦人的数学作业"><a href="#烦人的数学作业" class="headerlink" title="烦人的数学作业"></a><a href="https://www.luogu.com.cn/problem/P4999">烦人的数学作业</a></h4><p>题目简化：给你 $T$ 对数，每对数里有两个数 $l,r$ ，让我们求出 $[l,r]$ 里面每个数各位相加之和，答案对$1e9+7$ 取模</p>
<p>$T\le 20~~1\le x,y\le 10^{18}$</p>
<p>这个题嘛，我们完全可以像上个题一样，先求出各个数出现的次数，然后乘一下那个数是多少就行了，不放代码了（</p>
<h4 id="数页码"><a href="#数页码" class="headerlink" title="数页码"></a><a href="https://www.luogu.com.cn/problem/P1836">数页码</a></h4><p>题目描述：请你求出全部页码中所有单个数字的和</p>
<p>$1\le n \le 10^9$</p>
<p>这显然还不如上个题难（，下一个吧</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度</title>
    <url>/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">1s限时的范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">$10^{10^7}$</td>
</tr>
<tr>
<td style="text-align:center">O(log n)</td>
<td style="text-align:center">$10^{10^6}$</td>
</tr>
<tr>
<td style="text-align:center">O(sqrt n)</td>
<td style="text-align:center">$10^{15}$</td>
</tr>
<tr>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">$2\times 10^8$</td>
</tr>
<tr>
<td style="text-align:center">$O(nlogn)$</td>
<td style="text-align:center">$5 \times 10^6\sim5\times10^7$</td>
</tr>
<tr>
<td style="text-align:center">$O(nlog^2n)$</td>
<td style="text-align:center">$2 \times 10^5\sim 1\times 10^6$</td>
</tr>
<tr>
<td style="text-align:center">$O(n\sqrt n)$</td>
<td style="text-align:center">$2\times 10^5\sim5\times10^5$</td>
</tr>
<tr>
<td style="text-align:center">$O(n \sqrt n logn)$</td>
<td style="text-align:center">$5\times 10^4\sim10^5$</td>
</tr>
<tr>
<td style="text-align:center">$O(\frac{n^2}{\omega})$</td>
<td style="text-align:center">$2\times 10^4\sim10^5$</td>
</tr>
<tr>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$5\times 10^3\sim10^4$</td>
</tr>
<tr>
<td style="text-align:center">$O(\frac{n^3}{\omega})$</td>
<td style="text-align:center">$2\times10^3$</td>
</tr>
<tr>
<td style="text-align:center">$O(n^3)$</td>
<td style="text-align:center">$500$</td>
</tr>
<tr>
<td style="text-align:center">$O(2^n)$</td>
<td style="text-align:center">$20\sim28$</td>
</tr>
<tr>
<td style="text-align:center">$O(n2^n)$</td>
<td style="text-align:center">$20\sim24$</td>
</tr>
<tr>
<td style="text-align:center">$O(3^n)$</td>
<td style="text-align:center">$15\sim18$</td>
</tr>
<tr>
<td style="text-align:center">$O(n!)$</td>
<td style="text-align:center">$10\sim11$</td>
</tr>
<tr>
<td style="text-align:center">$O(n!n)$</td>
<td style="text-align:center">$9\sim10$</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路习题技巧</title>
    <url>/%E6%9C%80%E7%9F%AD%E8%B7%AF%E4%B9%A0%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="这次我们来看一下图论的一些有趣的操作与性质"><a href="#这次我们来看一下图论的一些有趣的操作与性质" class="headerlink" title="这次我们来看一下图论的一些有趣的操作与性质"></a>这次我们来看一下图论的一些有趣的操作与性质</h2><h4 id="spfa判断负环"><a href="#spfa判断负环" class="headerlink" title="spfa判断负环"></a>spfa判断负环</h4><p>首先我们把spfa的代码放过来：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">	dis[<span class="number">1</span>]=<span class="number">0</span>; vis[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">	Q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">int</span> x=Q.<span class="built_in">front</span>();</span><br><span class="line">		Q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[x]=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> y=edge[i].to,z=edge[i].w;</span><br><span class="line">			<span class="keyword">if</span>(dis[y]&gt;dis[x]+z)&#123;</span><br><span class="line">				dis[y]=dis[x]+z;</span><br><span class="line">				<span class="keyword">if</span>(!vis[y])&#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(y);</span><br><span class="line">					vis[y]=<span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后我们观察，一个数入队的条件是：前一个点当前的dis加上权值w&lt;当前扫描到的边的dis</p>
<p>那么如果出现正环，那么他们每一轮都不会相加，因为显然每加一轮会加上这个环的大小，所以正环不会出现死循环</p>
<p>但是如果出现负环，每一轮过后最短路都会变小，那么我们就可以用spfa来判断负环</p>
<p>方法：计算一下入队的数的个数如果大于等于n，就说明有负环，可以直接跳出了（此处用的是bfs的思路）<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">	dis[<span class="number">1</span>]=<span class="number">0</span>; vis[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">	Q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">int</span> x=Q.<span class="built_in">front</span>();</span><br><span class="line">		Q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[x]=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> y=edge[i].to,z=edge[i].w;</span><br><span class="line">			<span class="keyword">if</span>(dis[y]&gt;dis[x]+z)&#123;</span><br><span class="line">				dis[y]=dis[x]+z;</span><br><span class="line">				cnt[y]=cnt[x]+<span class="number">1</span>;  <span class="comment">//更新包含边数</span></span><br><span class="line">				<span class="keyword">if</span>(cnt[y]&gt;=n) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//判定存在负环</span></span><br><span class="line">				<span class="keyword">if</span>(!vis[y])&#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(y);</span><br><span class="line">					vis[y]=<span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面的更新包含边数可以再说一下，就是说，每当一个环出现，那么肯定要循环跑一串点，所以我们可以记录下每一个点进入多少次，如果一个点进入了n次及以上，就说明有负环了，可以直接跳出</span></span><br></pre></td></tr></table></figure></p>
<h4 id="建反边"><a href="#建反边" class="headerlink" title="建反边"></a>建反边</h4><p>我们先看一个题：对于一个有向图，从节点1出发，共n个点，每到一个节点立即返回，问最短的总路径是多少<br>易知我们从节点1到每个点可以用dijkstra跑一遍，那么怎么跑回来呢？每次循环再走一遍？那复杂度不堪设想<br>所以我们想到可以把边反过来建，这样我们算各个点到节点1的距离可以反过来，重新在建反边的前提下跑一遍dijkstra(1)，这就是建反边的思想</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列</title>
    <url>/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%EF%BC%88%E5%8C%85%E6%8B%AC%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%8D%95%E8%B0%83%E6%A0%88%EF%BC%89/</url>
    <content><![CDATA[<h3 id="栈和队列-此处均为用数组模拟"><a href="#栈和队列-此处均为用数组模拟" class="headerlink" title="栈和队列  此处均为用数组模拟"></a>栈和队列  此处均为用数组模拟</h3><p>栈：先进后出（可以理解成一个坑）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> stk[N],tt;</span><br><span class="line">skt[++tt]=x;<span class="comment">//入栈</span></span><br><span class="line">tt--;<span class="comment">//弹出</span></span><br><span class="line"><span class="keyword">if</span>(tt==<span class="number">0</span>) <span class="keyword">return</span> empty;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">not</span> empty;</span><br><span class="line"></span><br><span class="line">skt[tt]<span class="comment">//栈顶</span></span><br></pre></td></tr></table></figure>
<p>队列：先进先出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> q[N],hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">q[++tt]=x;<span class="comment">//插入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(hh&lt;=tt) <span class="keyword">not</span> empty;</span><br><span class="line"><span class="keyword">else</span> empty<span class="comment">//判断队列是否为空</span></span><br><span class="line">    </span><br><span class="line">hh++;<span class="comment">//弹出</span></span><br></pre></td></tr></table></figure>
<p>应用：单调栈，单调队列（滑动窗口）</p>
<p>一定要自己手模拟几遍，增强记忆，充分理解</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>树形DP</title>
    <url>/%E6%A0%91%E5%BD%A2DP/</url>
    <content><![CDATA[<h1 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h1><p>定义：在树上进行DP操作（没了）</p>
<h2 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h2><h4 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h4><p>两次dfs，第一次从任意一个点出发，跑到最远的一个点，然后第二次从最远的那个点开始跑，找到最远的一个点，两个点之间的路径就是树的直径</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt,val;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="keyword">int</span> head[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt].val=w;</span><br><span class="line">    e[cnt].to=v;</span><br><span class="line">    e[cnt].nxt=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;dis[u]&lt;&lt;endl;</span></span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].to,w=e[i].val;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        dis[v]=dis[u]+w;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[i]&gt;ans) ans=dis[i],pos=i;</span><br><span class="line">        dis[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="built_in">dfs</span>(pos);</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=<span class="built_in">max</span>(ans,dis[i]);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h4><p>我们设$f_x$表示$x$当前的最大值</p>
<p>然后就结束了</p>
<p>直接由其下面的几个子树的最大值和次大值相加就行了</p>
<p>最后记录答案就行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,val,nxt;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="keyword">int</span> head[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt].val=w;</span><br><span class="line">    e[cnt].to=v;</span><br><span class="line">    e[cnt].nxt=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> d1=<span class="number">0</span>,d2=<span class="number">0</span>;<span class="comment">///存当前节点各个子树的较大值和次大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].to,w=e[i].val;</span><br><span class="line">        <span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> d=<span class="built_in">dp</span>(v,u)+w;</span><br><span class="line">        tag=<span class="built_in">max</span>(tag,d);</span><br><span class="line">        <span class="keyword">if</span>(d&gt;d1) d2=d1,d1=d;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d&gt;d2) d2=d;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,d1+d2);</span><br><span class="line">    <span class="keyword">return</span> tag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树的中心"><a href="#树的中心" class="headerlink" title="树的中心"></a>树的中心</h2><blockquote>
<p>题目描述：请你在树中找到一个点，使得该点到树中其他结点的最远距离最近。<br>典型的换根DP了，我们发现每一个点的转移的代价是可以由前一个点继承来的，所以可以直接进行树上DP</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt,val;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="keyword">int</span> head[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt].val=w;</span><br><span class="line">    e[cnt].to=v;</span><br><span class="line">    e[cnt].nxt=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>; <span class="keyword">char</span> c=<span class="built_in">getchar</span>(); <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c=<span class="built_in">getchar</span>()) f |= c==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c=<span class="built_in">getchar</span>()) x = (x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">if</span>(f) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">short</span> st[<span class="number">30</span>],tp;</span><br><span class="line">    <span class="keyword">do</span> st[++tp] = x%<span class="number">10</span>, x/=<span class="number">10</span>; <span class="keyword">while</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(tp) <span class="built_in">putchar</span>(st[tp--] | <span class="number">48</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p1[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> up[N];</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; down[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dfs_down</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].to,w=e[i].val;</span><br><span class="line">        <span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> d=<span class="built_in">dfs_down</span>(v,u)+w;</span><br><span class="line">        <span class="keyword">if</span>(down[u].first&lt;d)&#123;</span><br><span class="line">            p1[u]=v;</span><br><span class="line">            down[u].second=down[u].first;</span><br><span class="line">            down[u].first=d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(down[u].second&lt;d) down[u].second=d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> down[u].first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs_up</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].to,w=e[i].val;</span><br><span class="line">        <span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p1[u]==v) up[v]=<span class="built_in">max</span>(down[u].second,up[u])+w;</span><br><span class="line">        <span class="keyword">else</span> up[v]=<span class="built_in">max</span>(up[u],down[u].first)+w;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs_up</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u),<span class="built_in">read</span>(v),<span class="built_in">read</span>(w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs_down</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">dfs_up</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=<span class="built_in">min</span>(ans,<span class="built_in">max</span>(down[i].first,up[i]));</span><br><span class="line">    <span class="built_in">write</span>(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分</title>
    <url>/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
    <content><![CDATA[<h1 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>已知一棵包含 N 个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：</p>
<ul>
<li><code>1 x y z</code>，表示将树从$x$到$y$结点最短路径上所有节点的值都加上$z$。</li>
<li><code>2 x y</code>，表示求树从$x$到$y$结点最短路径上所有节点的值之和。</li>
<li><code>3 x z</code>，表示将以$x$为根节点的子树内所有节点值都加上$z$。</li>
<li><code>4 x</code> 表示求以$x$为根节点的子树内所有节点值之和</li>
</ul>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>重儿子：父亲节点的所有儿子中子树结点数目最多($size$最大)的结点；</p>
<p>轻儿子：父亲节点中除了重儿子以外的儿子；</p>
<p>重边：父亲结点和重儿子连成的边；</p>
<p>轻边：父亲节点和轻儿子连成的边；</p>
<p>重链：由多条重边连接而成的路径；</p>
<p>轻链：由多条轻边连接而成的路径；</p>
<h2 id="思路框架"><a href="#思路框架" class="headerlink" title="思路框架"></a>思路框架</h2><p>树链剖分，简称就是树剖，指的是通过把树剖成若干个链后选择用数据结构维护以实现树上的操作</p>
<p>树剖的实际上就是两遍预处理，第一步要算出以下数据：<br>对于任意节点u的<code>深度</code>、<code>子树大小</code>、<code>重儿子编号</code>、<code>父节点编号</code>；分别记为：$\text{depth , size , son , fa}$这点用一个简单的dfs就可以实现，时间复杂度$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    fa[u]=fa;</span><br><span class="line">    size[u]=<span class="number">1</span>;</span><br><span class="line">    dep[u]=dep[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[v]&gt;t)&#123;</span><br><span class="line">        	t=siz[v];</span><br><span class="line">        	son[u]=v;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二遍预处理，则需要计算：<br>对于任意节点u的<code>所在重链顶点</code>，<code>第几个被遍历</code>，分别记为$\text{top , id}$ ，时间复杂度也是线性的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    top[u]=f;</span><br><span class="line">    id[u]=++tot;</span><br><span class="line">    val[tot]=w[u];</span><br><span class="line">    <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;<span class="comment">//指叶子节点</span></span><br><span class="line">    <span class="built_in">dfs2</span>(son[u],f);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa[u]||v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们以$\text{dfn}$序排列的val值建树。</p>
<p>然后我们处理题目中的四个操作</p>
<p>我们要记住两个性质：</p>
<p>1、一条重链上的点$\text{id}$连续<br>2、一棵子树上的点$\text{id}$也连续</p>
<p>第一个我们是要在一条链上做加法，那么我们就是应该先去剖出这条链<br>第二个我们是要在在链上查询，和上一个大同小异</p>
<p>第三个是要在树上做加法<br>第四个我们是要在树上查询</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_path</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">        <span class="built_in">upd_tree</span>(id[top[u]],id[u],k,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        u=fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">    <span class="built_in">upd_tree</span>(id[u],id[v],k,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query_path</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">        res+=<span class="built_in">query_tree</span>(id[top[u]],id[u],<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        u=fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">    res+=<span class="built_in">query_tree</span>(id[u],id[v],<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_son</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="built_in">upd_tree</span>(id[u],id[u]+siz[u]<span class="number">-1</span>,k,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query_son</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query_tree</span>(id[u],id[u]+siz[u]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lc</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> p&lt;&lt;<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rc</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt,to;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="keyword">int</span> head[N],cnt;</span><br><span class="line"><span class="keyword">int</span> dep[N],siz[N],fa[N],top[N],id[N],son[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tree[N&lt;&lt;<span class="number">2</span>],tag[N&lt;&lt;<span class="number">2</span>],w[N],val[N],mod;</span><br><span class="line"><span class="keyword">int</span> n,rt,T,tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].nxt=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    fa[u]=f;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    dep[u]=dep[f]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[v]&gt;t)&#123;</span><br><span class="line">            t=siz[v];</span><br><span class="line">            son[u]=v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    top[u]=f;</span><br><span class="line">    id[u]=++tot;</span><br><span class="line">    val[tot]=w[u];</span><br><span class="line">    <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;<span class="comment">//指叶子节点</span></span><br><span class="line">    <span class="built_in">dfs2</span>(son[u],f);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa[u]||v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线段树操作----------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p]=(tree[<span class="built_in">lc</span>(p)]+tree[<span class="built_in">rc</span>(p)])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[p]=val[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,<span class="built_in">lc</span>(p));</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r,<span class="built_in">rc</span>(p));</span><br><span class="line">    <span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tag[p])&#123;</span><br><span class="line">        tag[<span class="built_in">lc</span>(p)]+=tag[p];</span><br><span class="line">        tag[<span class="built_in">rc</span>(p)]+=tag[p];</span><br><span class="line">        tree[<span class="built_in">lc</span>(p)]+=tag[p]*(mid-l+<span class="number">1</span>);</span><br><span class="line">        tree[<span class="built_in">rc</span>(p)]+=tag[p]*(r-mid);</span><br><span class="line">        tag[p]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd_tree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k,<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//把l到r这段区间全部加k，总区间为m,n</span></span><br><span class="line">    k%=mod;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=m&amp;&amp;n&lt;=r)&#123;</span><br><span class="line">        tree[p]+=(n-m+<span class="number">1</span>)*k;</span><br><span class="line">        tag[p]+=k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(m+n)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(m,n,p);</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">upd_tree</span>(l,r,k,m,mid,<span class="built_in">lc</span>(p));</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">upd_tree</span>(l,r,k,mid+<span class="number">1</span>,n,<span class="built_in">rc</span>(p));</span><br><span class="line">    <span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query_tree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=m&amp;&amp;n&lt;=r) <span class="keyword">return</span> tree[p];</span><br><span class="line">    <span class="keyword">int</span> mid=(m+n)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(m,n,p);</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) sum+=<span class="built_in">query_tree</span>(l,r,m,mid,<span class="built_in">lc</span>(p));</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) sum+=<span class="built_in">query_tree</span>(l,r,mid+<span class="number">1</span>,n,<span class="built_in">rc</span>(p));</span><br><span class="line">    <span class="keyword">return</span> sum%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线段树操作-------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//路径操作---------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_path</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">        <span class="built_in">upd_tree</span>(id[top[u]],id[u],k,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        u=fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">    <span class="built_in">upd_tree</span>(id[u],id[v],k,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query_path</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">        res+=<span class="built_in">query_tree</span>(id[top[u]],id[u],<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        u=fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">    res+=<span class="built_in">query_tree</span>(id[u],id[v],<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//路径操作----------------------------------------------------------</span></span><br><span class="line"><span class="comment">//树上操作----------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_son</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="built_in">upd_tree</span>(id[u],id[u]+siz[u]<span class="number">-1</span>,k,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query_son</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query_tree</span>(id[u],id[u]+siz[u]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树上操作----------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;T&gt;&gt;rt&gt;&gt;mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;w[i],w[i]%=mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++) cin&gt;&gt;u&gt;&gt;v,<span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    <span class="built_in">dfs1</span>(rt,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(rt,rt);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;top[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;id[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,op,k;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>) cin&gt;&gt;y&gt;&gt;k, <span class="built_in">add_path</span>(x,y,k);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">2</span>) cin&gt;&gt;y, cout&lt;&lt;<span class="built_in">query_path</span>(x,y)&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">3</span>) cin&gt;&gt;k, <span class="built_in">add_son</span>(x,k);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">4</span>) cout&lt;&lt;<span class="built_in">query_son</span>(x)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8 10 2 448348</span></span><br><span class="line"><span class="comment">458 718 447 857 633 264 238 944 </span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">6 2</span></span><br><span class="line"><span class="comment">1 5</span></span><br><span class="line"><span class="comment">5 7</span></span><br><span class="line"><span class="comment">8 6</span></span><br><span class="line"><span class="comment">3 7 611</span></span><br><span class="line"><span class="comment">4 6</span></span><br><span class="line"><span class="comment">3 1 267</span></span><br><span class="line"><span class="comment">3 2 111</span></span><br><span class="line"><span class="comment">1 6 3 153</span></span><br><span class="line"><span class="comment">3 7 673</span></span><br><span class="line"><span class="comment">4 8</span></span><br><span class="line"><span class="comment">2 6 1</span></span><br><span class="line"><span class="comment">4 7</span></span><br><span class="line"><span class="comment">3 4 228</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵乘法</title>
    <url>/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/</url>
    <content><![CDATA[<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h5 id="矩阵的定义："><a href="#矩阵的定义：" class="headerlink" title="矩阵的定义："></a>矩阵的定义：</h5><p>一个n*m的矩阵可以看作是一个二维数组 </p>
<p>设A是$n <em> m$矩阵，B是 $m </em> p$矩阵</p>
<p>则C就是$n * p$ 矩阵 并且</p>
<script type="math/tex; mode=display">
\sum _{k=1}^{m} A_{i,k}*B_{k,j}</script><p>矩阵乘法满足结合律，即$(A<em>B)</em>C$ =$A<em>(B</em>C)$<br>              满足分配律，即$(A+B)<em>C$=$A</em>C+B*C$</p>
<hr>
<h5 id="矩阵的递推应用"><a href="#矩阵的递推应用" class="headerlink" title="矩阵的递推应用"></a>矩阵的递推应用</h5><p>若F1 是 $1<em>n$ 矩阵，F2是 $n</em>n$ 矩阵,F3=F1 F2  </p>
<p>F1,F3可看作一维数组</p>
<p>这时我们发现，矩阵乘法就可以用来做一些递推式</p>
<p>举个<img src="https://img2020.cnblogs.com/blog/1823105/202109/1823105-20210923222313900-698841718.png" alt="image"></p>
<p>假如一个递推式是 $f[i]=f[i-1]+f[i-2]$(斐波那契数列)</p>
<p>那么它的我们就可以设它的A矩阵为</p>
<p>A={$f[i-1]$  $f[i]$}</p>
<p>想要得到的C矩阵就应该是</p>
<p>C={$f[i]$  $f[i+1]$}</p>
<p>此时，我们是不是只要找到一个$n<em>n$的B矩阵就可以使得$A</em>B=C$</p>
<p>那么怎么构造B矩阵呢？首先我们要理解一下C数组</p>
<p>$C[i][j]$表示的应该就是A数组第i行的每个数分别乘上B数组第j行的每个数</p>
<p>那么对于这个题来说</p>
<p>我们要得到的$C[1][1]$是不是$f[i]$</p>
<p>那么我们只要$f[i-1]$乘上0，f[i]乘上1是不是就行了</p>
<p>所以说B的第一列是0,1</p>
<p>另外</p>
<p>我们观察$f[i+1]$ 显然$f[i+1]=f[i]+f[i-1]$，</p>
<p>所以我们要让$f[i-1]<em>1+f[i]</em>1$</p>
<p>所以B数组就是</p>
<p>0    1</p>
<p>1    1</p>
<p>我们可以这样写<br>同时我们发现，F3=F1*F2</p>
<p>F4=F3*F2</p>
<p>$F5=F4<em>F2=F3</em>F2<em>F2=F1</em>F2^3$</p>
<p>即$Fn=F1*F2^{n-1}$</p>
<p><strong>upd</strong>:我发现了一种新的推式子的好方法：<br>对于</p>
<script type="math/tex; mode=display">
a_{x}= \begin{cases}1 & x \in\{1,2,3\} \\ a_{x-1}+a_{x-3} & x \geq 4\end{cases}</script><p>我们可以选择进行一次新的矩阵变换：</p>
<script type="math/tex; mode=display">
A = f_{i-3},f_{i-2},f_{i-1} \\
C = f_{i-2},f_{i-1},f_{i}</script><p>我们尝试竖着写（等会会很有用的）</p>
<script type="math/tex; mode=display">
C=
\left[\begin{array}{c}
f_i \\
f_{i-1} \\
f_{i-2}
\end{array}\right]</script><script type="math/tex; mode=display">
A=
\left[\begin{array}{c}
f_{i-1} \\
f_{i-2} \\
f_{i-3}
\end{array}\right]</script><p>那么我们这样做：<br>直接看看C的每一个式子是怎么推出来的，但是位置和顺序不能换，0也得写上去</p>
<script type="math/tex; mode=display">
f_{i}=1\times f_{i-1}+0\times f_{i-2}+1\times f_{i-3};\\
f_{i-1}=1\times f_{i-1}+0\times f_{i-2}+0\times f_{i-3};\\
f_{i-2}=0\times f_{i-1}+1\times f_{i-2}+0\times f_{i-3};</script><p>把前面的每一个系数取出来<br>所以我们的矩阵 $B$ 最后就长成</p>
<script type="math/tex; mode=display">
1~~0~~1\\
1~~0~~0\\
0~~1~~0</script><p>这个是对的，不信自己试试看？</p>
<p>但是应该你得把A和B换一下，要不不满足矩阵乘了</p>
<p>最后贴一份矩阵快速幂的代码罢<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">namespace</span> scan&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">        x=<span class="number">0</span>; <span class="keyword">char</span> c=<span class="built_in">getchar</span>(); <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c=<span class="built_in">getchar</span>()) f |= c==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c=<span class="built_in">getchar</span>()) x = x*<span class="number">10</span>+(c^<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">if</span>(f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T x,<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">short</span> st[<span class="number">30</span>],tp;</span><br><span class="line">        <span class="keyword">do</span> st[++tp] = x%<span class="number">10</span>, x/=<span class="number">10</span>; <span class="keyword">while</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(tp) <span class="built_in">putchar</span>(st[tp--] | <span class="number">48</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> scan;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[N][N];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(a));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A;</span><br><span class="line"></span><br><span class="line">Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;A,<span class="keyword">const</span> Matrix &amp;B)&#123;</span><br><span class="line">    Matrix C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                C.a[i][j]=(C.a[i][j]+A.a[i][k]*B.a[k][j])%mod;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line">Matrix ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>) ans=ans*A;</span><br><span class="line">        A=A*A;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n),<span class="built_in">read</span>(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">read</span>(A.a[i][j]);</span><br><span class="line">    ans.<span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">qpow</span>(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">write</span>(ans.a[i][j],<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>技巧</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>简单数学</title>
    <url>/%E7%AE%80%E5%8D%95%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="常见概念和符号"><a href="#常见概念和符号" class="headerlink" title="常见概念和符号"></a>常见概念和符号</h2><h3 id="整除-同余常见符号"><a href="#整除-同余常见符号" class="headerlink" title="整除/同余常见符号"></a>整除/同余常见符号</h3><span id="more"></span>
<ol>
<li><p>整除符号 $x\mid y$，表示 $x$ 整除 $y$ ，即 $x$ 是 $y$ 的因数</p>
</li>
<li><p>取模符号 $x \bmod y$ ，表示 $x$ 除以 $y$ 以后的余数</p>
</li>
<li><p>互质符号 $x~\bot~y$ ，表示 $x$ ，$y$ 互质</p>
</li>
<li><p>最大公约数 $\gcd(x,y)$</p>
</li>
<li><p>最小公倍数 $\text{lcm} (x,y)$</p>
</li>
</ol>
<h3 id="数论函数常见符号"><a href="#数论函数常见符号" class="headerlink" title="数论函数常见符号"></a>数论函数常见符号</h3><p>求和符号：$\sum$ 符号，表示满足特定条件的数的和</p>
<ol>
<li><p>$\sum _{i=1} ^{n} ai$ 表示 $a_1\sim a_n$ 的和</p>
</li>
<li><p>$\sum_{S\subseteq T} |S|$</p>
</li>
</ol>
<p>求积符号：$\Pi$ 符号，表示满足特定条件的数的积</p>
<ol>
<li>$\Pi_{i=1}^n$ 表示 $n!$ </li>
<li>$\Pi _{i=1}^{n} a_i$ 表示从 $a_1\sim a_n$ 的积</li>
<li>$\Pi _{x\mid d} x$ 表示 $d$ 的所有因数的乘积</li>
</ol>
<p>整除符号：$\mid$ ，$a \mid b$ 表示 $a$ 是 $b$ 的约数 $b$ 不被 $a$ 整除记作 $a \nmid b$ 。</p>
<p>同余符号：$\equiv$ ，$a\equiv b \pmod c$ 表示 $\dfrac a c -\lfloor \dfrac a c \rfloor=\dfrac b c-\lfloor \dfrac b c \rfloor$   或者说 $a/c$ 和 $b/c$ 的余数相同</p>
<h3 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h3><p>数论函数指定义域为正整数的函数。数论函数也可以视作一个数列。</p>
<h3 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h3><p>若 $f(n)$ 表示 $f(1)=1$ 且 $\forall x,y \in N_+$   $\gcd(x,y)=1$ 都有 $f(xy)=f(x)f(y)$，则 $f(n)$ 为积性函数</p>
<p> 若 $f(n)$ 表示 $f(1)=1$ 且 $\forall x,y \in N_+$  都有 $f(xy)=f(x)f(y)$，则 $f(n)$ 为完全积性函数</p>
<h2 id="导数公式"><a href="#导数公式" class="headerlink" title="导数公式"></a>导数公式</h2><p>$(C)^{‘}=0$                                   $(x^\mu)’=\mu x^{\mu-1}$</p>
<p>$(a^x)’=a^x\ln x$ ( $a$ 为常数）    $(\sin x)’=\cos x$</p>
<p>$(\cos x)’=-\sin x$                    $(\tan x)’=\sec^2x$</p>
<p>$(\cot x)’=-\csc^2x$                  $(\sec x)’=\sec x \cot x$</p>
<p>$(\csc x)’=-\csc x\cot x$           $(\ln x)’=\dfrac{1}{x}$</p>
<p>$({\log_a}^x)’=\dfrac{1}{x\ln a}$                    $(e^x)’=e^x$</p>
<p>加减公式：</p>
<p>$(u\pm v)’=u’\pm v’$           $(Cu)’=Cu’$ （C是常数）</p>
<p>$(uv)’=u’v+uv’$            $(\dfrac{u}{v})’=(\dfrac{u’v-uv’}{v^2})$</p>
<h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>设$a,b$为实数，$i^2=-1$，形如$a+bi$的数叫复数，其中$i$被称为虚数单位，复数域是目前已知最大的域</p>
<p>在复平面中，$x$ 代表实数，$y$ 轴（除原点外的点）代表虚数，从原点$(0,0)$到$(a,b)$的向量表示复数$a+bi$</p>
<p><strong>模长</strong>：从原点$(0,0)$到点$(a,b)$的距离，即$\sqrt{a^2+b^2}$</p>
<p><strong>幅角</strong>：假设以逆时针为正方向，从x<em>x</em>轴正半轴到已知向量的转角的有向角叫做幅角</p>
<p><strong>计算</strong>：平行四边形法则(其实就是分配律)，注意这里的$i^2$为-1：</p>
<p>几何定义：复数相乘，模长相乘，幅角相加<del>(至今我也没看懂)</del></p>
<p>$(a+bi)\times (c+di)=ac+bdi^2+bci+adi=ac-bd+(bc+ad)i$</p>
<p>同时，我们由向量的知识迁移到复数上来，定义 <strong>复数的模</strong> 就是复数所对应的向量的模。</p>
<p>复数 $z=a+bi$ 的模 $|z|=\sqrt{a^2+b^2}$</p>
<p>于是为了方便，我们常把复数 $z=a+bi$ 称为点 $Z$ </p>
<p>由向量的知识我们发现，虚数不可以比较大小</p>
<p>复数满足交换律，结合律，对加法的分配律</p>
<p>当两个虚数实部相等，虚部互为相反数时，这两个复数互为 <strong>共轭复数</strong>。</p>
<p>即 $z=a+bi$ 的共轭复数为 $z=a-bi$</p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>一般均是在二进制下来说</p>
<h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><p>1.<strong>与 (&amp;)</strong> 两个对应位都为 $1$ 时才为 $1$ </p>
<p>2.<strong>或 (|)</strong> 只要两个对应位中有一个 $1$ 时就为 $1$ </p>
<p>3.<strong>异或(^)</strong> 只有两个对应位不同时才为 $1$</p>
<h3 id="取反"><a href="#取反" class="headerlink" title="取反(~)"></a>取反(~)</h3><p>把0变成1，把1变成0</p>
<p>补码：在二进制表示下，正数和 的补码为其本身，负数的补码是将其对应正数按位取反后加一。</p>
<p>应用：$\text{lowbit}(x)=(x)\&amp;(-x)$  取出最后一个等于1的位数，具体原因想一想</p>
<h3 id="左移和右移"><a href="#左移和右移" class="headerlink" title="左移和右移"></a>左移和右移</h3><p><code>num&lt;&lt;i</code> 表示将 $num$ 的二进制表示向左移动1位所得的值。</p>
<p><code>num&gt;&gt;i</code> 表示将 $num$ 的二进制表示向右移动1位所得的值。</p>
<p>注意：<code>+</code> 和<code>-</code>的优先级高于左移右移</p>
<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> base 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cut 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L 10000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Big</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> num[L];</span><br><span class="line">    <span class="built_in">Big</span>()&#123;</span><br><span class="line">        len=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">    &#125;</span><br><span class="line">    Big <span class="keyword">operator</span>=(<span class="keyword">const</span> Big &amp;a)&#123;</span><br><span class="line">        len=a.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) num[i]=a.num[i];</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> a)&#123;</span><br><span class="line">        <span class="keyword">return</span> num[a];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> a)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num[a];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> istream&amp;<span class="keyword">operator</span>&gt;&gt;(istream&amp;,Big&amp;);</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp;<span class="keyword">operator</span>&lt;&lt;(ostream&amp;,Big&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Big a,<span class="keyword">const</span> Big b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.len!=b.len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.len&gt;b.len) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	    <span class="keyword">if</span>(a[i]&gt;b[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Big a,<span class="keyword">const</span> Big b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.len!=b.len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)</span><br><span class="line">     <span class="keyword">if</span>(a[i]!=b[i])</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Big a,<span class="keyword">const</span> Big b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b || a==b)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Big <span class="keyword">operator</span>+(Big a,Big b)&#123;</span><br><span class="line">    Big ret;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;;i++)&#123;</span><br><span class="line">        ret[i]=a[i]+b[i]+carry;</span><br><span class="line">        carry=ret[i]/base;</span><br><span class="line">        ret[i]%=base;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=a.len&amp;&amp;i&gt;=b.len&amp;&amp;carry==<span class="number">0</span>)</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret.len=<span class="built_in">min</span>(L,<span class="built_in">max</span>(a.len,b.len)+<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span>(ret.len&gt;<span class="number">0</span>&amp;&amp;ret[ret.len<span class="number">-1</span>]==<span class="number">0</span>)</span><br><span class="line">     ret.len--;</span><br><span class="line">    <span class="keyword">if</span>(ret.len==<span class="number">0</span>)</span><br><span class="line">     ret.len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Big <span class="keyword">operator</span>+(Big a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> carry=b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;;i++)&#123;</span><br><span class="line">        a[i]+=carry;</span><br><span class="line">        carry=a[i]/base;</span><br><span class="line">        a[i]%=base;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">0</span> &amp;&amp; carry==<span class="number">0</span> &amp;&amp; i&gt;=a.len)</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a.len=<span class="built_in">min</span>(L,a.len+<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span>(a.len&gt;<span class="number">0</span> &amp;&amp; a[a.len<span class="number">-1</span>]==<span class="number">0</span>) a.len--;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Big <span class="keyword">operator</span>*(Big a,Big b)&#123;</span><br><span class="line">    Big ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b.len;j++) ret[i+j]+=a[i]*b[j];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;;i++)&#123;</span><br><span class="line">        ret[i]+=carry;</span><br><span class="line">        carry=ret[i]/base;</span><br><span class="line">        ret[i]%=base;</span><br><span class="line">        <span class="keyword">if</span>(ret[i]==<span class="number">0</span> &amp;&amp; carry==<span class="number">0</span> &amp;&amp; i&gt;=a.len+b.len<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a.len=<span class="built_in">min</span>(L,a.len+b.len+<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span>(a.len&gt;<span class="number">0</span> &amp;&amp; a[a.len<span class="number">-1</span>]==<span class="number">0</span>) a.len--;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Big <span class="keyword">operator</span>*(Big a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;;i++)&#123;</span><br><span class="line">        carry+=a[i]*b;</span><br><span class="line">        a[i]=carry%base;</span><br><span class="line">        carry/=base;</span><br><span class="line">        <span class="keyword">if</span>(carry==<span class="number">0</span>&amp;&amp;a[i]==<span class="number">0</span>&amp;&amp;i&gt;=a.len) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a.len=<span class="built_in">min</span>(L,a.len+<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span>(a.len&gt;<span class="number">0</span>&amp;&amp;a[a.len<span class="number">-1</span>]==<span class="number">0</span>) a.len--;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Big <span class="keyword">operator</span>-(Big a,Big b)&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;;i++)&#123;</span><br><span class="line">        a[i]-=b[i]+carry;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;<span class="number">0</span>) carry=(-a[i]/base+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> carry=<span class="number">0</span>;</span><br><span class="line">        a[i]+=carry*base;</span><br><span class="line">        <span class="keyword">if</span>(carry==<span class="number">0</span>&amp;&amp;i&gt;=b.len) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a.len&gt;<span class="number">0</span>&amp;&amp;a[a.len<span class="number">-1</span>]==<span class="number">0</span>) a.len--;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Big <span class="keyword">operator</span>-(Big a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> carry=b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;;i++)&#123;</span><br><span class="line">        a[i]-=carry;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;<span class="number">0</span>) carry=(-a[i]/base+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> carry=<span class="number">0</span>;</span><br><span class="line">        a[i]+=carry*base;</span><br><span class="line">        <span class="keyword">if</span>(carry==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a.len&gt;<span class="number">0</span> &amp;&amp; a[a.len<span class="number">-1</span>]==<span class="number">0</span>) a.len--;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Big <span class="keyword">operator</span>/(Big a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">     <span class="keyword">long</span> <span class="keyword">long</span> carry=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=a.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">         a[i]+=carry*base;</span><br><span class="line">         carry=a[i]%b;</span><br><span class="line">         a[i]/=b;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span>(a.len&gt;<span class="number">0</span>&amp;&amp;a[a.len<span class="number">-1</span>]==<span class="number">0</span>) a.len--;</span><br><span class="line">     <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Big <span class="keyword">operator</span>%(<span class="keyword">const</span> Big a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">     <span class="keyword">return</span> a-(a/b)*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数论-1"><a href="#数论-1" class="headerlink" title="数论"></a>数论</h2><h3 id="整除性质"><a href="#整除性质" class="headerlink" title="整除性质"></a>整除性质</h3><script type="math/tex; mode=display">
\begin{aligned}
&a\mid b \Longleftrightarrow-a\mid  b \Longleftrightarrow a\mid -b \Longleftrightarrow|a| \mid \lvert b\rvert  \\
&a\mid b \wedge b\mid  c \Rightarrow a \mid c \\
&a\mid b \wedge a\mid  c \Longleftrightarrow \forall x, y \in \mathbb{Z}, a \mid x b+y c \\
&a\mid b \wedge b\mid  a \Rightarrow b=\pm a \\
&\text{设 } m \neq 0 \text { ，那么 } a\mid b \Longleftrightarrow m a\mid  m b \text { } \\
&\text{设 } b \neq 0 \text { ，那么 } a\mid b \Rightarrow\mid  a\mid \leq\mid  b \mid \\
&\text{设 } a \neq 0, b=q a+c \text { ，那么 } a\mid b \Longleftrightarrow a\mid  c_{。}
\end{aligned}</script><h3 id="同余性质"><a href="#同余性质" class="headerlink" title="同余性质"></a>同余性质</h3><script type="math/tex; mode=display">
\begin{aligned}
&\text { - 自反性: } a \equiv a(\bmod m) . \\
&\text { - 对称性: 若 } a \equiv b(\bmod m) \text {, 则 }~ b \equiv a(\bmod m) ~. \\
&\text { - 传递性: 若 } a \equiv b(\bmod m), b \equiv c(\bmod m) \text {, 则 } a \equiv b(\bmod m) . \\
&\text { - 线性运算: 若 } a, b, c, d \in \mathbf{Z}, m \in \mathbf{N}^{*}, a \equiv b(\bmod m), c \equiv d(\bmod m) \text { 则有: } \\
&\text { - } a \pm c \equiv b \pm d(\bmod m) \text {. } \\
&\text { - } a \times c \equiv b \times d(\bmod m) \text {. } \\
&\text { - 若 } a, b \in \mathbf{Z}, k, m \in \mathbf{N}^{*}, a \equiv b(\bmod m) \text {, 则 } a k \equiv b k(\bmod m k) . \\
&\text { - 若 } a, b \in \mathbf{Z}, d, m \in \mathbf{N}^{*}, d\mid a, d\mid  b, d \mid m, \text { 则当 } a \equiv b(\bmod m) \text { 成立时，有 } \\
&\frac{a}{d} \equiv \frac{b}{d}\left(\bmod \frac{m}{d}\right) . \\
&\text { - 若 } a, b \in \mathbf{Z}, d, m \in \mathbf{N}^{*}, d \mid m, \text { 则当 } a \equiv b(\bmod m) \text { 成立时，有 } a \equiv b(\bmod d) . \\
&\text { - 若 } a, b \in \mathbf{Z}, d, m \in \mathbf{N}^{*} \text {, 则当 } a \equiv b(\bmod m) \text { 成立时，有 } \operatorname{gcd}(a, m)=\operatorname{gcd}(b, m), \\
&\text { 若 } d \text { 能整除 } m \text { 及 } a, b \text { 中的一个，则 } d \text { 必定能整除 } a, b \text { 中的另一个。 }
\end{aligned}</script><h3 id="最大公约数与最小公倍数"><a href="#最大公约数与最小公倍数" class="headerlink" title="最大公约数与最小公倍数"></a>最大公约数与最小公倍数</h3><p>若干个数所有约数中的共同的最大数是<strong>最大公约数</strong>，倍数中共同的最小数是<strong>最小公倍数</strong></p>
<p>一般两个数的最大公约数是 $\gcd$ 最小公倍数是 $\mathrm{lcm}$ </p>
<p>$\gcd(a,b)<em>\mathrm{lcm}(a,b)=a</em>b$</p>
<p>求法：辗转相除</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span>?a:<span class="built_in">gcd</span>(b,a%b);&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h3><p>整除分块是用于快速处理形似</p>
<script type="math/tex; mode=display">
\sum _ {i=1} ^n \lfloor \dfrac n i\rfloor</script><p>的式子的办法</p>
<h4 id="引理1"><a href="#引理1" class="headerlink" title="引理1"></a>引理1</h4><script type="math/tex; mode=display">
\forall a,b,c \in Z,\lfloor \dfrac a {bc} \rfloor =\lfloor \dfrac{\lfloor \frac a b \rfloor} c \rfloor</script><p>证明略</p>
<h4 id="引理2"><a href="#引理2" class="headerlink" title="引理2"></a>引理2</h4><p>对于一个较大的 $n$  我们显然会发现，我们后面的这个下取整取值并不是每一次都随着 $i$ 而变化的，它是呈块状分布的，同时这个下取整的值我们也能得到，应该是共有 $2\sqrt n$ 个值</p>
<h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><p>通过严谨的数学推理<del>(打表)</del> 我们发现实际上这些取值是有规律的，即</p>
<p>如果一个块的开始位置时 $l$ 那么它的结束位置 $r$ 就是 $\lfloor \dfrac n {\lfloor \frac n l \rfloor} \rfloor$</p>
<p>那么我们写程序的基本结构就很显然了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>) r=n/(n/l);</span><br></pre></td></tr></table></figure>
<p>所以我们对于形如：</p>
<script type="math/tex; mode=display">
\sum _{i=1} ^ n f(i)\lfloor \dfrac n i\rfloor</script><p>可以对 $f(i)$ 可以直接前缀和预处理，就可以解决这道问题了</p>
<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>$φ(n)$ :定义：1~n中与n互质的数的个数</p>
<p>公式：</p>
<script type="math/tex; mode=display">
设N=p1^{α1}*p2^{α2}*p3^{α3}...</script><script type="math/tex; mode=display">
则\varphi(N)= N*(1-\frac{1}{p1})*(1-\frac{1}{p2})...</script><h3 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h3><p>我们一般表示为 $\mu(x)$ </p>
<ol>
<li>$\exists d_i\ge 2$，$\mu(x)=0$</li>
<li>$\forall d_i=1$，$\mu(x)=(-1)^k$ ($k$ 是质因数分解后有几项)</li>
<li>$x=1$ ，$\mu(x)=1$</li>
</ol>
<p>如：</p>
<p>$\mu(6)=1$ $\mu(7)=-1$ $\mu(8)=0$</p>
<p>设 $s(n)=\sum_{i=d\mid n}^{n} \mu (i)$ </p>
<p>如 $s(6) = \mu(1) +\mu(2) +\mu(3) +\mu(6)$</p>
<p>那么：</p>
<ol>
<li>当 $n=1$，$s(n)=1$</li>
<li>当 $n&gt;1$，$s(n)=0$</li>
</ol>
<p>对于<code>2</code>的证明：</p>
<p>首先我们对于 $n$ 因式分解：$n=p_1^{\alpha_1}\times p_2^{\alpha_2}\times\dots\times p_k^{\alpha_k}$  ($k\ge 1$)</p>
<p>那么我们的每一个 $d$ 都有：$d=p_1^{\beta_1}\times p_2^{\beta_2}\times\dots\times p_k^{\beta_k}$   ($\forall i \in [1,k]$  $0\le\beta_i\le \alpha_i$)</p>
<p>那么我们算一下 $\mu(d)$ 可知，我们只需要考虑，如果$\exists i \in [1,k]$，$\beta_i\ge 2$ 则原式为0</p>
<p>所以我们只需要看里面有多少个1即可</p>
<p>所以我们用组合数算一下：</p>
<script type="math/tex; mode=display">
\mu(x)=\sum_{i=0}^{k} \binom k i (-1)^i</script><p>我们这时候看一下二项式定理：</p>
<script type="math/tex; mode=display">
(a+b)^k=\sum _{i=0}^{k} \binom k i a^i b^{k-i}</script><p>钦定 $a=1$ $b=-1$</p>
<script type="math/tex; mode=display">
(1-1)^k=\sum_{i=0}^{k} \binom k i (-1)^i=0</script><p>所以 $\mu(x)$ 必然等于=0，<strong>得证</strong></p>
<h3 id="各种筛法"><a href="#各种筛法" class="headerlink" title="各种筛法"></a>各种筛法</h3><h4 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h4><p>用于统计从1-n中的质数</p>
<p><code>原理</code>：从前往后筛，如果筛到一个数$i$，然后把$i$的倍数都删了</p>
<p>时间复杂度：$O(nlog^2n)$ 基本可以跑到3e5</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">statistics</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) prime[++k]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;prime[j]*i&lt;=n;j++)&#123;</span><br><span class="line">            st[prime[j]*i]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h4><p>这个东西很重要，关系到后面的积性函数求解</p>
<p>先放一个代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) prime[++k]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;prime[j]*i&lt;=n;j++)&#123;</span><br><span class="line">            st[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%prime[j])) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们观察和上面那个的区别</p>
<p>发现无非就是多了一行<code>if(i%prime[j]==0) break;</code></p>
<p>我们先给个证明来说明这句话加上后的正确性</p>
<p>证明</p>
<p>当$i$是$prime[j]$的整数倍时$\iff prime[j]\mid i$</p>
<p>设 $k=i/prime[j]$</p>
<p>则 $i<em>prime[j+1]=prime[j]</em>(prime[j+1]*k)$</p>
<p>所以说 $i*prime[j]$ 是 $prime[j]$ 的整数倍</p>
<p>不需要继续标记</p>
<p>对于 $prime[j+2]*i$ 等同理，所以说可以直接跳出循环，不需要重新标记</p>
<p>这样线性筛的复杂度就可以被优化到 $O(n)$ 了</p>
<h4 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h4><p>我们可以把这件求phi分成两步</p>
<p>k是质数</p>
<p>首先我们容易发现一个问题：如果$k$是质数，那么$\varphi (k)$显然等于$k-1$，因为小于$k$的数都与$k$互质</p>
<p>所以我们可以把这一句：<code>if(!vis[i]) p[++num]=i;</code>再加上一句<code>phi[i]=i-1;</code></p>
<ol>
<li><p>$i\%p=0$ 时</p>
<p> 然后我们需要证明一个东西：</p>
<p> 若$p\mid i$且$p$为质数 则 $\varphi(i<em>p)$=$p</em>\varphi(i)$</p>
<p> <strong>证明：</strong></p>
<p> 若$p \mid i$  则可以推出$p$ 是 $i$ 的一个质因子</p>
<p> 我们发现：<strong>一个数的欧拉函数与每一项的次数无关</strong></p>
<p> 所以说</p>
<script type="math/tex; mode=display">
 \varphi(i*p)=i*p*(1-\frac{1}{p_1})*(1-\frac{1}{p_2})...*(1-\frac{1}{p_k})</script><p> 同时</p>
<script type="math/tex; mode=display">
 \varphi(i)=i*(1-\frac{1}{p_1})*(1-\frac{1}{p_2})...*(1-\frac{1}{p_k})</script><p> 发现两个式子除了 $i*p$ 全部相同</p>
<p> 所以我们可以推出 $\varphi(i<em>p)$=$p</em>\varphi(i)$</p>
<p> 证毕</p>
<p> 那么很显然在这一句中<code>if(i%prime[j]==0) break;</code>我们可以加上<code>phi[prime[j]*i]=prime[j]*phi[i]</code></p>
</li>
<li><p>$i\%p!=0$ 时</p>
<p> $p$ 一定是 $i*p_j$ 的最小质因子</p>
<p> 先把 $\varphi(i)$ 的式子摆在这</p>
<script type="math/tex; mode=display">
 \varphi(i)=i*(1-\frac{1}{p_1})*(1-\frac{1}{p_2})...*(1-\frac{1}{p_k})</script><p> 然后</p>
<script type="math/tex; mode=display">
 \varphi(p*i)=p*i*(1-\frac{1}{p_1})*(1-\frac{1}{p_2})...*(1-\frac{1}{p_k}*(1-\frac{1}{p}))</script><p> 我们把下面的式子除以上面的式子发现：</p>
<script type="math/tex; mode=display">
 \varphi(p*i)/\varphi(i)=p*(1-\frac{1}{p})=p-1</script><p> 把 $\varphi(i)$ 挪到右边最后可以得到</p>
<script type="math/tex; mode=display">
 \varphi(p*i)=\varphi(i)*(p-1)</script><p> 所以我们讨论完了所有的情况，可以得到最终式子：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_euler</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            phi[i]=i<span class="number">-1</span>;</span><br><span class="line">            prime[++cnt]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;prime[j]*i&lt;=n &amp;&amp; j&lt;=cnt;j++)&#123;</span><br><span class="line">            st[prime[j]*i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                phi[i*prime[j]]=prime[j]*phi[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[i*prime[j]]=phi[i]*(prime[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="莫比乌斯筛"><a href="#莫比乌斯筛" class="headerlink" title="莫比乌斯筛"></a>莫比乌斯筛</h4><p>这个比较简单，就不写了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_euler</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            mu[i]=-</span><br><span class="line">            phi[i]=i<span class="number">-1</span>;</span><br><span class="line">            prime[++cnt]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;prime[j]*i&lt;=n &amp;&amp; j&lt;=cnt;j++)&#123;</span><br><span class="line">            st[prime[j]*i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                phi[i*prime[j]]=prime[j]*phi[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i*prime[j]]=-mu[i];</span><br><span class="line">            phi[i*prime[j]]=phi[i]*(prime[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h3><h4 id="试除法"><a href="#试除法" class="headerlink" title="试除法"></a>试除法</h4><p>用于单个数检验是否为质数</p>
<p><code>原理</code>：从1枚举到$\sqrt n$观察是否有数能被n整除</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>) </span><br><span class="line">                vec[x].<span class="built_in">push_back</span>(i),n/=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n) vec[x].<span class="built_in">push_back</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Miller-Rabin"><a href="#Miller-Rabin" class="headerlink" title="Miller-Rabin"></a>Miller-Rabin</h4><p>用法：$O(k\log^2n)$ 判断 $n$ 是否是质数。其中 $k$ 是枚举底数的个数，$2^{78}$ 以内只需要枚举 $12$ 个。</p>
<p>费马小定理：</p>
<p>若 $p$ 是质数且 $p \nmid a$ </p>
<script type="math/tex; mode=display">
a^{p-1} \equiv 1 \pmod p</script><p>我们可以根据<code>费马小定理</code>得出一种检验素数的思路(<code>Fermat 素性测试</code>)：</p>
<p>它的基本思想是不断地选取在 $[2,n)$ 中的 $a$，并检验是否每次都有 $a^{n−1}\equiv 1 \pmod n$</p>
<p>但是很遗憾，费马小定理的逆定理并不成立</p>
<p>卡迈克尔数：如果有一个合数 $n$ 满足任何一个 $a$ 都满足 $a^{n−1}\equiv 1 \pmod n$，那么我们称这个合数 $n$ 为卡迈克尔数，同时，满足 $m=2^n-1$ 那么 $m$ 还是卡迈克尔数，所以卡迈克尔数是无穷的</p>
<p>二次探测定理：</p>
<p>若 $p$ 是奇素数，则 $x^2 \equiv 1 \pmod p$ 的解为 $x=1$ 或 $x=p-1$ $\pmod p$</p>
<p>算法流程：</p>
<p>（1）对于偶数和 0，1，2 可以直接判断。</p>
<p>（2）设要测试的数为 $x$，我们取一个较小的质数 $a$，设 $s,t$，满足$2^s\times t=x-1$ （其中 $t$ 是奇数）。</p>
<p>（3）我们先算出 $a^t$，然后不断地平方并且进行二次探测（进行 $s$ 次）。</p>
<p>（4）最后我们根据费马小定律，如果最后 $a^{x-1}\not\equiv 1 \pmod x$，则说明 $x$ 为合数。</p>
<p>（5）多次取不同的 $a$ 进行 $Miller-Rabin$ 素数测试，这样可以使正确性更高</p>
<p>备注：</p>
<p>（1）我们可以多选择几个 $a$，如果全部通过，那么 $x$ 大概率是质数。</p>
<p>（2）$Miller-Rabin$ 素数测试中，“大概率”意味着概率非常大，基本上可以放心使用。</p>
<p>（3）当 $a$ 取前12个素数时，可以证明  $2^{78}$ 范围内的数不会出错。</p>
<p>（5）另外，如果是求一个 $\text{long long}$ 类型的平方，可能会爆掉，因此有时我们要用快速乘，不能直接乘。</p>
<p>$\text{Pollard-Rho}$ 先咕了</p>
<h3 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h3><p>对于二元一次方程 $ax+by=c$，有整数解的充要条件是 $\gcd(a,b) \mid c$。</p>
<p>推论：当 $ax+by=1$ 时，当且仅当 $\gcd(a,b)=1$ 时有解。</p>
<p><strong>证明</strong>：</p>
<p>设 $d=\gcd(a,b)$ 则 $d \mid a,d\mid b$。由整除的性质 $\forall x,y\in Z$，有 $d \mid (ax+by)。$</p>
<p>设 $s$ 为 $ax+by$ 最小正值，令 $q=\left\lfloor \dfrac{a}{s} \right\rfloor$。</p>
<p>则 $r=a\pmod s=a-q(ax+by)=a(1-qx)+b(-qy)$。</p>
<p>可见 $r$ 也为的线性组合。 </p>
<p>由于 $r$ 为 $a\pmod s$ 所得，所以 $0\leq r&lt;s$。</p>
<p>由于 $s$ 为线性组合的最小正值,可知。</p>
<ol>
<li><p>因此有 $ s\mid a$ ，同理 $s\mid b$ ，因此，$s$ 是 $a$ 与 $b$ 的公约数，所以 $d\ge s$。</p>
<p> 因为 $d\mid a$ ，$d\mid b$ ，且 $s$ 是 $a$ 与 $b$ 的一个线性组合，所以由整除性质知 $d\mid s$。</p>
</li>
<li><p>但由于 $d\mid s$ 和 $s&gt;0$，因此 $d\le s$。</p>
</li>
</ol>
<p>由 1,2 得 $d=s$ ，命题得证。</p>
<h3 id="exgcd"><a href="#exgcd" class="headerlink" title="exgcd"></a>exgcd</h3><p>现在我们对于 $ax+by=c$ 想要获得一组整数解。</p>
<p>首先 $c$ 肯定是要满足 $\gcd(a,b) \mid c$ 的（<del>要不然裴蜀定理白证明了</del>）。</p>
<p>然后我们可以直接求 $a_1x+b_1y=\gcd(a_1,b_1)$ 的一组整数解，最后 $x,y$ 再乘上 $c/\gcd(a_1,b_1)$ 即可</p>
<p>好了，我们现在说怎么求解。</p>
<p>当 $b=0$ 时，显然 $x=1,y=0$</p>
<p>当 $b\not= 0$ 时，有：</p>
<p>$ax+by=\gcd(a,b)$</p>
<p>$\because\gcd(b,a\bmod b)=\gcd(a,b)$</p>
<p>$\therefore a  x + b  y = \gcd ( a , b ) = \gcd ( b , a \bmod b ) = b \times t x + ( a   \bmod b ) \times t y$</p>
<p>$\because a \bmod b=a- \left\lfloor \dfrac{a}{b} \right\rfloor\times b$</p>
<p>$\therefore a x+b y=b\times tx+(a- \left\lfloor \dfrac{a}{b} \right\rfloor\times b)\times ty=a\times ty+b\times(tx−\left\lfloor \dfrac{a}{b} \right\rfloor\times ty)$</p>
<p>$\therefore x=ty,y=tx-\left\lfloor \dfrac{a}{b} \right\rfloor\times ty$</p>
<p>此时我们容易发现： $x$ 和 $y$ 都被转化成了两个更小的数，然后递归求解即可        </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span>#<span class="meta-keyword">define</span> ll long long using namespace std;ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123;	<span class="meta-keyword">if</span>(!b)&#123;		x=1;y=0;		return a;	&#125;	<span class="meta-keyword">else</span>&#123;		ll tx,ty;		ll d=exgcd(b,a%b,tx,ty);		x=ty;y=tx-(a/b)*ty;		return d;	&#125;&#125;int main()&#123;	ll a,b,k,x,y;scanf(<span class="meta-string">&quot;%lld%lld%lld&quot;</span>,&amp;a,&amp;b,&amp;k);	ll d=exgcd(a,b,x,y);	<span class="meta-keyword">if</span>(k%d)&#123;puts(<span class="meta-string">&quot;no solution!&quot;</span>);return 0;&#125;	<span class="meta-keyword">else</span>&#123;		x=x*k/d;		y=(k-a*x)/b;	&#125;	printf(<span class="meta-string">&quot;%lld %lld\n&quot;</span>,x,y);	return 0;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><script type="math/tex; mode=display">
\text{若 }\gcd(a,m)=1, \text{则 }a^{\varphi(m)\equiv 1}\pmod m</script><p>证明：</p>
<p>设 $x_1,x_2,\dots,x_{\varphi(m)}$ 是 $[1,m]$ 里面与 $m$ 互质的数，由于在 $\bmod m$ 意义下两两不同且余数都与 $m$ 互质</p>
<p>因此我们推理：$ax_i$ 必定也是 $\bmod m$ 意义下两两不同且余数都与 $m$ 互质的数</p>
<p>所以：</p>
<script type="math/tex; mode=display">
x_1x_2\dots x_{\varphi(m)} \equiv ax_1ax_2\dots ax_{\varphi(m)}\pmod m</script><script type="math/tex; mode=display">
1\equiv a^{\varphi(m)} \pmod m</script><h3 id="拓展欧拉定理"><a href="#拓展欧拉定理" class="headerlink" title="拓展欧拉定理"></a>拓展欧拉定理</h3><script type="math/tex; mode=display">
a^{b} \equiv \begin{cases}a^{b ~\bmod~ \varphi(m)} & \operatorname{gcd}(a, m)=1 \\ a^b & \operatorname{gcd}(a, m) \neq 1, b<\varphi(m) \quad(\bmod m) \\ a^{(b~ \bmod ~\varphi(m))+\varphi(m)} & \operatorname{gcd}(a, m) \neq 1, b \geq \varphi(m).\end{cases}</script><p>推理：<a href="[欧拉定理 &amp; 费马小定理 - OI Wiki](https://oiwiki.com/math/number-theory/fermat/">Oi Wiki</a>)</p>
<h3 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h3><p>定义：若 $ax\equiv 1\pmod b$ 且 $a$ 与 $b$ 互质，那么我们就能定义 $x$ 为 $a$ 的逆元，记为 $a^{-1}$ ，所以我们也能称 $x$ 为 $a$ 在 $\pmod b$ 意义下的倒数，此时我们对于 $\dfrac{a}{b}~\pmod p$，我们就可以求出 $b$ 在 $\pmod p$ 意义下的逆元，来代替 $\dfrac{1}{b}$</p>
<h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><p>由费马小定理：若 $p$ 为素数，$a$ 为正整数，且 $a$ 、$p$ 互质。则有 $a^{p-1}\equiv 1\pmod p$</p>
<p>所以 </p>
<script type="math/tex; mode=display">
\dfrac{a}{b}=a\times b^{-1}\equiv a\times b^{p-2} \pmod p</script><p>所以我们用快速幂算出来 $a\times b^{p-2}$ 就有 $\dfrac{a}{b}$ 的逆元的值了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span>using namespace std;typedef long long ll;int mod;ll power(ll k,ll p)&#123;	ll ans=1;	while(p)&#123;		<span class="meta-keyword">if</span>(p&amp;1) ans=ans*k%mod;		k=k*k%mod;		p&gt;&gt;=1;	&#125;	return ans;&#125;ll a,b;int main()&#123;	scanf(<span class="meta-string">&quot;%lld%lld&quot;</span>,&amp;a,&amp;mod);<span class="comment">//算a的逆元	printf(&quot;%lld&quot;,a*power(b,mod-2)%mod);	return 0;&#125;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="拓展欧几里得"><a href="#拓展欧几里得" class="headerlink" title="拓展欧几里得"></a>拓展欧几里得</h4><p>求解 $ax\equiv c \pmod b$ 中 $c=1$ 的情况。我们可以转化为求解 $ax+by=1$ 的解</p>
<p>所以：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;	<span class="keyword">if</span>(!b)&#123;		x=<span class="number">1</span>;y=<span class="number">0</span>;		<span class="keyword">return</span> a;	&#125;	<span class="keyword">else</span>&#123;		ll tx,ty;		ll d=<span class="built_in">exgcd</span>(b,a%b,tx,ty);		x=ty;y=tx-(a/b)*ty;		<span class="keyword">return</span> d;	&#125;&#125;<span class="keyword">int</span> a,p,x,y;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;p);    <span class="keyword">int</span> d=<span class="built_in">exgcd</span>(a,p,x,y);    x=(x%p+p)%p;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线性求逆元"><a href="#线性求逆元" class="headerlink" title="线性求逆元"></a>线性求逆元</h4><p> 首先，我们设 $p=kx+r$</p>
<p>那么我们很容易发现：$kx+r\equiv 0\pmod p$</p>
<p>此时，我们左右同时乘上 $k^{-1}r^{-1}$ 可得</p>
<p>$kr^{-1}+x^{-1}\equiv 0\pmod p$</p>
<p>$\therefore x^{-1}\equiv -kr^{-1}\pmod p$</p>
<p>把 $k=\left\lfloor \dfrac{p}{x} \right\rfloor$ $r=p \bmod x$ 代入，得</p>
<p>$x^{-1}\equiv -\left\lfloor \dfrac{p}{x} \right\rfloor \times (p \bmod i)^{-1} \pmod p$</p>
<h4 id="阶乘求逆元"><a href="#阶乘求逆元" class="headerlink" title="阶乘求逆元"></a>阶乘求逆元</h4><p>首先，有如下的一个关系：</p>
<p>$inv_{i+1}=\dfrac{1}{(i+1)!}$</p>
<p>$inv_{i+1}*(i+1)=\dfrac{1}{i!}\times \dfrac{1}{n+1}\times (n+1)=\dfrac{1}{i!}=inv_i^{-1}$</p>
<p>所以我们可以先求出 $n$ 的逆元，然后逆推即可</p>
<p>同时，我们也可以发现 $\dfrac{1}{i}$ 的逆元就是：$\dfrac{1}{i!}\times (i-1)!=\dfrac{1}{n}\pmod p$</p>
<h3 id="Lucas"><a href="#Lucas" class="headerlink" title="Lucas"></a>Lucas</h3><p>定理：</p>
<script type="math/tex; mode=display">
\binom{a}{b}=\binom{a \bmod p}{b \bmod p} \times \binom{\frac{a}{p}}{\frac{b}{p}}\pmod p</script><h3 id="中国剩余定理-CRT"><a href="#中国剩余定理-CRT" class="headerlink" title="中国剩余定理(CRT)"></a>中国剩余定理(CRT)</h3><p>定理：对于下列一些式子的整数求出符合条件的最小的正整数 $x$</p>
<script type="math/tex; mode=display">
\left\{  
             \begin{array}a
             x\equiv x_1\pmod {m_1}\\  
             x\equiv x_2\pmod {m_2}\\  
             ……\\
             x\equiv x_n\pmod {m_n}
             \end{array}  
\right.</script><p>首先，若$(m_1,m_2\dots m_n)$两两互质</p>
<p>我们即可直接令 $M=m_1\times m_2\dots\times m_n$</p>
<p>则令 $M_i=\dfrac{M}{m_i}$</p>
<p>当 $x$ 满足 $x = x_1\times M_1\times M_1^{-1}+x_2\times M_2\times M_2^{-1}\dots $ 时</p>
<p>一定符合上面的式子</p>
<h3 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><p><strong>形式一：</strong></p>
<script type="math/tex; mode=display">
f(x)=\sum_{d\mid x} g(d) \iff g(x)=\sum_{d\mid x} \mu(d)f(\dfrac x d)</script><p>证明：</p>
<script type="math/tex; mode=display">
\begin{align*}
\sum_{d\mid x} \mu(d)f(\dfrac x d)&=\sum_{d\mid x} \mu(d)\sum_{i\mid \frac x d} g(i)\\
&=\sum_{i\mid x}g(i) \sum_{d\mid \frac x i} \mu(d)
\end{align*}</script><p>我们容易发现：对于右边的式子 $\sum_{i\mid x}g(i) \sum_{d\mid \frac x i} \mu(d)$ </p>
<p>结合莫比乌斯函数刚才推的性质<code>2</code>，我们很容易得到该式 $=f(x)$</p>
<p><strong>得证</strong></p>
<p><strong>形式二：</strong></p>
<script type="math/tex; mode=display">
f(n)=\sum_{n\mid d} g(d) \iff \sum_{n\mid d}\mu(\dfrac d n) f(d)</script>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p><del>一种我琢磨了很长时间才明白的数据结构</del><br>核心思想就是把一个序列，分成一个二叉树，叶子节点存的是每个元素，能够快速修改或访问区间中的数值，<del>功能♂强大</del><br>线段树主要分为下面几步：</p>
<h4 id="push-up操作"><a href="#push-up操作" class="headerlink" title="push_up操作"></a>push_up操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p]=tree[<span class="built_in">lc</span>(p)]+tree[<span class="built_in">rc</span>(p)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个很简单</p>
<h4 id="build操作"><a href="#build操作" class="headerlink" title="build操作"></a>build操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[p]=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,<span class="built_in">lc</span>(p));</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r,<span class="built_in">rc</span>(p));</span><br><span class="line">    <span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是一个递归<br>先建左子树，再建右子树，最后合并起来更新根节点</p>
<p>但是这里我们要注意哈，如果你是像我一样以这种形式<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[N],n,m,tree[N&lt;&lt;<span class="number">2</span>],tag[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> x,y,k;</span><br></pre></td></tr></table></figure><br>存树的话,那么build操作就没别的事了<br>还有的大佬是把每个节点的.l=cnt 这种形式的，那么还得进行其他操作，具体看别的大佬的博客，当然，我的这种方式是空间最小的</p>
<p>下面一步就是核心了（</p>
<h4 id="pushdown操作"><a href="#pushdown操作" class="headerlink" title="pushdown操作"></a>pushdown操作</h4><p>我们把一个tag数组，或者叫它lazy数组，来省事，这么想，如果多次修改了同一个点的大小，我们每次子啊那么大的一个树里，改那么多数看起来是不是很亏，那么不妨在查询之前，我们先把这些要加的数存起来，等到一定时刻需要查询时再加</p>
<p>但是这样有个问题，这些数我们存到哪呢？<br>伟大的OIer先辈们早已给我们整理好了</p>
<p>如果节点p加上了k<br>那么先让tree[p]+=k;然后让tag[p]也加上k，</p>
<p>等到需要的时候，我们把这个p传下去，然后让下面的节点的tag[lc(p)]+=k,<br>这是我们看小标题，这个操作叫做pushdown（push：推，down：下面）（推下去）<br>那么我们就可以考虑，推下去以后 子树 tree会变，tag会变，我们分别改一下，tag刚才其实已经改过了，只需要该tree就行了，tree更好改了，tag[p]存的是欠下面的数，然后子树的tree就要加上tag[p]* （子树的长度）<br>此时这个根节点已经做到应该做的了,所以tag[p]=0;<br>最后放上代码<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tag[p])&#123;</span><br><span class="line">        tag[<span class="built_in">lc</span>(p)]+=tag[p];</span><br><span class="line">        tag[<span class="built_in">rc</span>(p)]+=tag[p];</span><br><span class="line">        tree[<span class="built_in">lc</span>(p)]+=tag[p]*(mid-l+<span class="number">1</span>);</span><br><span class="line">        tree[<span class="built_in">rc</span>(p)]+=tag[p]*(r-mid);</span><br><span class="line">        tag[p]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>update和query 区间修改和区间查询就直接背就行了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k,<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//把l到r这段区间全部加k，总区间为m,n</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=m&amp;&amp;n&lt;=r)&#123;</span><br><span class="line">        tree[p]+=(n-m+<span class="number">1</span>)*k;</span><br><span class="line">        tag[p]+=k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(m+n)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(m,n,p);</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">update</span>(l,r,k,m,mid,<span class="built_in">lc</span>(p));</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">update</span>(l,r,k,mid+<span class="number">1</span>,n,<span class="built_in">rc</span>(p));</span><br><span class="line">    <span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=m&amp;&amp;n&lt;=r) <span class="keyword">return</span> tree[p];</span><br><span class="line">    <span class="keyword">int</span> mid=(m+n)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(m,n,p);</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) sum+=<span class="built_in">query</span>(l,r,m,mid,<span class="built_in">lc</span>(p));</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) sum+=<span class="built_in">query</span>(l,r,mid+<span class="number">1</span>,n,<span class="built_in">rc</span>(p));</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>完结撒花</strong></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>背包DP</title>
    <url>/%E8%83%8C%E5%8C%85DP/</url>
    <content><![CDATA[<h1 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h1><h5 id="问题：有n个物品，每个重量为vi-权值为wi，每个物品仅用一次-问在背包容量为W里能装的最大价值"><a href="#问题：有n个物品，每个重量为vi-权值为wi，每个物品仅用一次-问在背包容量为W里能装的最大价值" class="headerlink" title="问题：有n个物品，每个重量为vi,权值为wi，每个物品仅用一次,问在背包容量为W里能装的最大价值"></a>问题：有n个物品，每个重量为vi,权值为wi，每个物品仅用一次,问在背包容量为W里能装的最大价值</h5><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h5 id="核心特点：每件物品最多只能用一次"><a href="#核心特点：每件物品最多只能用一次" class="headerlink" title="核心特点：每件物品最多只能用一次"></a>核心特点：每件物品最多只能用一次</h5><h5 id="集合条件："><a href="#集合条件：" class="headerlink" title="集合条件："></a>集合条件：</h5><p>核心：不漏下任何一个</p>
<p>1.只从前i个物品中选<br>2.总体积$\le$V</p>
<h5 id="属性：Max"><a href="#属性：Max" class="headerlink" title="属性：Max"></a>属性：Max</h5><p>$f_{i,j}$据上面的假设，意义应该是在前i个物品，当前已选的物品的最大价值</p>
<p>把$f_{i,j}$表示的所有选法分为两大类：</p>
<p>1.不选第i个物品<br>2.选第i个物品</p>
<h5 id="计算：-f-i-j"><a href="#计算：-f-i-j" class="headerlink" title="计算：$f_{i,j}$"></a>计算：<strong>$f_{i,j}$</strong></h5><p>如果是第1类的话显然</p>
<script type="math/tex; mode=display">
f_{i,j}=f_{i-1,j}</script><p>第2类的话我们考虑：<br>$f_{i,j}$应该可以从上一个位置推过来<br>那么上一个位置的背包容量应该就是 j-v[i]</p>
<p>同时由于第i位的东西必须选<br>所以说这个位置的转移方程应该是</p>
<script type="math/tex; mode=display">
f_{i,j}=f_{i-1,j-v[i]}+w[i]</script><p>综上：我们要的应该是两个集合的最大值  所以说：</p>
<script type="math/tex; mode=display">
f_{i,j}=max(f_{i-1,j-v[i]}+w[i],f_{i-1,j})</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> v[N],w[N],f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i]) f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时我们还可以考虑到一个问题我们发现第i个物品一定是从上一个物品的某一个体积的背包里整过来的</p>
<p>那么我们就可以考虑空间的优化</p>
<p>$f_{j}$让它表示背包容量为j时的最大容积即可</p>
<p>那么我们看一下第二重循环</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">    f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">    <span class="keyword">if</span>(j&gt;=v[i]) f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个我们直观考虑应该写成这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">    f[j]=[j];</span><br><span class="line">    <span class="keyword">if</span>(j&gt;=v[i]) f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们看f[j]=f[j]显然是一句废话，删掉就行</p>
<p>$f[j]$的转移看着也没太大毛病</p>
<p>等等，还有点问题</p>
<p>首先，由于我们枚举的是体积，那么问题应该在于当j&lt;v[i]时，这个转移显然时废掉了（j-v[i]此时显然小于0）<br>所以我们可以从v[i]开始枚举</p>
<p>其次，我们考虑一下，我们的第i种状态是不是都是从i-1转移而来的</p>
<p>所以我们的此时是不是也应该做到我们每次取max的两个数也要是上一重循环的数，而不能是这次已经覆盖过的，因此，我们要从m枚举到v[i]</p>
<p>综上所述：</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> v[N],w[N],f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=v[i];j--) </span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">    cout&lt;&lt;f[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>核心特点：每件物品可以装无限次</p>
<p>假设每一个物品背包装满时最多选k个</p>
<p>那么转移方程很显然</p>
<script type="math/tex; mode=display">
f_{i,j}=max(f_{i-1,j},f_{i-1,j-k*v[i]}+k*w[i])</script><p>那么很容易得到朴素做法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> v[N],w[N],f[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k*v[i]&lt;=j;k++)&#123;</span><br><span class="line">                f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j - k * v[i]]+ k * w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样是三重循环预计连1000 1000的数据都过不了，考虑优化</p>
<p>我们可以把右边的玩意们列出来：</p>
<script type="math/tex; mode=display">
f_{i,j}=max(f_{i-1,j},f_{i-1,j-v[i]*1}+w[i],f_{i-1,j-v[i]*2}+w[i]*2...)</script><p>然后我们再写一个式子</p>
<script type="math/tex; mode=display">
f_{i,j-v[i]}=max(f_{i-1,j-v[i]*1},f_{i-1,j-v[i]*2}+w[i]*1...)</script><p>观察相似之处,我们发现第一个的那个式子除了第一个以外，其余的显然都是等于$f_{i,j-v[i]}+w[i]$的</p>
<p>所以原式就可以轻易的化为</p>
<script type="math/tex; mode=display">
f_{i,j}=max(f_{i,j},f_{i,j-v[i]}+w[i])</script><p>瞬间干掉了k所在的那个循环</p>
<p>而且我们借用上一个题的那个思想，空间方面i的这一层显然也可以干掉</p>
<p>最终式子</p>
<script type="math/tex; mode=display">
f_{j}=max(f_{j},f_{j-v[i]}+w[i])</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> v[N],w[N],f[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=v[i];j&lt;=m;j++)</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">    cout&lt;&lt;f[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>核心特点：每件物品最多有Si个</p>
<p>朴素做法的话和刚才的朴素写法一样</p>
<p>我们先把式子写出来</p>
<script type="math/tex; mode=display">
f_{i,j}=max(f_{i-1,j},f_{i-1,j-k*v[i]}+k*w[i])</script><h3 id="二进制优化"><a href="#二进制优化" class="headerlink" title="二进制优化"></a>二进制优化</h3><p>前置知识，一个数一定可以用$2^n$的数拼凑出来</p>
<p>原因：1,2 可以凑出来1~3</p>
<p>1~3分别加上4就是1~7</p>
<p>同理也可以加上8</p>
<p>证毕（<del>其实很显然啊喂</del>）</p>
<p>然后我们就可以将1,2,4,8,16,32,64,128,256，c……分别打包成一个区间</p>
<p>（$1+2+4……2^k+c=s$，$2^k＜c&lt;2^k+1$）</p>
<p>然后很显然我们就可以把它转化成01背包问题了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> w[N],v[N],f[N];</span><br><span class="line"><span class="keyword">int</span> n,m,cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,s,k=<span class="number">1</span>;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;s;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;=s)&#123;</span><br><span class="line">            v[++cnt]=a*k;</span><br><span class="line">            w[cnt]=b*k;</span><br><span class="line">            s-=k; k*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s) v[++cnt]=a*s,w[cnt]=b*s;</span><br><span class="line">    &#125;</span><br><span class="line">    n=cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=v[i];j--) f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">    cout&lt;&lt;f[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于担心大家记混，我总结出了一个小技巧：</p>
<p>对于前面的三个背包,只有完全背包是从小到大枚举空间，其余的一定是从大到小</p>
<p>时间复杂度：$O(n^2logn)$</p>
<h3 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h3><p>我们直接把式子全部列出来，会发现下面的性质：</p>
<script type="math/tex; mode=display">
f_{i,j}=max(f_{i-1,j},f_{i,j-v}+w,f_{i-1,j-2v}+2w……f_{i-1,j-sv}+sw)</script><script type="math/tex; mode=display">
f_{i,j-v}=max(f_{i-1,j-v},f_{i-2,j-2v}+w......f_{i-1,j-sv}+(s-1)w,f_{i-1,(s+1)v}+sw)</script><p>其实上下我们发现是不能乱搞的，因为还有$f_{i-1,j}$和$f_{i-1,j-(s+1)v}+sw$是空白的</p>
<p><img src="C:\Users\NOIstu\AppData\Roaming\Typora\typora-user-images\image-20211029180900981.png" alt="image-20211029180900981"></p>
<p>所以我们就可以直接用长度为s的互动窗口，维护每个窗口的最大值</p>
<h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><p>核心特点：有若干组，每组里面最多选一个物品（<del>假如说有个瓜摊，选了生瓜蛋子就不能选熟瓜了</del>）</p>
<p>状态转移：</p>
<p>若选这一组的东西   $f_{i,j}=f_{i-1,j-v[i][k]}+w[i][k]$ </p>
<p>若不选的话：          $f_{i,j}=f_{i-1,j}$ </p>
<p>求两个集合的最大值：取Max</p>
<script type="math/tex; mode=display">
f_{i,j}=max(f_{i-1,j},f_{i-1,j-v[i][k]}+w[i][k])</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> v[N][N],s[N],w[N][N],f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=s[i];j++) cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=s[i];k++) </span><br><span class="line">                <span class="keyword">if</span>(j&gt;=v[i][k]) f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i][k]]+w[i][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数</title>
    <url>/%E7%BB%84%E5%90%88%E6%95%B0/</url>
    <content><![CDATA[<h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><h3 id="定义式"><a href="#定义式" class="headerlink" title="定义式"></a>定义式</h3><script type="math/tex; mode=display">
\binom{a}{b}=\dfrac{a!}{b!(a-b)!}</script><h3 id="递推式"><a href="#递推式" class="headerlink" title="递推式"></a>递推式</h3><script type="math/tex; mode=display">
\binom{a}{b}=\binom{a-1}{b}+\binom{a-1}{b-1}</script><h3 id="lucas定理"><a href="#lucas定理" class="headerlink" title="lucas定理"></a>lucas定理</h3><script type="math/tex; mode=display">
\binom{a}{b}=\binom{a \bmod p}{b \bmod p}\times \binom{\frac{a}{p}}{\frac b p}\pmod p</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=a;i&lt;=b;i++,j--)</span><br><span class="line">		res=res*j%p,</span><br><span class="line">		res=res*<span class="built_in">qpow</span>(i,p<span class="number">-2</span>)%p;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lucas</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a&lt;p &amp;&amp; b&lt;p) <span class="keyword">return</span> <span class="built_in">C</span>(a,b,p);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">C</span>(a%p,b%p,p)*<span class="built_in">lucas</span>(a/p,b/p,p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><p>长度为 $2n$ 的合法括号序列数量：</p>
<script type="math/tex; mode=display">
\text{Catalan}_n=\binom{2n}{n}-\binom{2n}{n-1}=\dfrac{\binom {2n}{n}}{(n+1)}</script>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>莫比乌斯反演</title>
    <url>/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<h2 id="莫比乌斯反演例题"><a href="#莫比乌斯反演例题" class="headerlink" title="莫比乌斯反演例题"></a>莫比乌斯反演例题</h2><p>原理：</p>
<script type="math/tex; mode=display">
f(x)=\sum_{d\mid x} g(d) \iff g(x)=\sum_{d\mid x} \mu(d)f(\dfrac x d)</script><script type="math/tex; mode=display">
f(x)=\sum_{x\mid d} g(d) \iff \sum_{x\mid d}\mu(\dfrac d x) f(d)</script><p>技巧：</p>
<script type="math/tex; mode=display">
[\gcd (x,y)=1]=\sum_{d\mid \gcd(x,y)} \mu(d)</script><script type="math/tex; mode=display">
\sum _{d\mid n} \mu(d) = [n=1]</script><script type="math/tex; mode=display">
d(i\times j) =\sum_{x\mid i} \sum _{y\mid j}[\gcd(x,y)==1]</script><p>对于这种与 $\gcd$ 相关的莫比乌斯反演，一般我们都是套路的去设 $f(d)$ 为 $\gcd (i,j)=d$ 的个数，$g(n)$ 为 $\gcd (i,j)=n$ 和 $n$ 的倍数的数的个数</p>
<p>即：</p>
<script type="math/tex; mode=display">
f(d)=\sum_{i=1}^n \sum_{j=1}^m [\gcd(i,j)=d]</script><script type="math/tex; mode=display">
g(x)=\sum_{i=1}^n \sum_{j=1}^m [x\mid\gcd(i,j)]</script><p>由定义我们容易发现：$f(x)$ 和 $g(x)$ 是有某些关联的，那么我们尝试去发现 $f(x)$ 和 $g(x)$ 的关系，可以发现：</p>
<script type="math/tex; mode=display">
g(x)=\sum_{x\mid d} f(d)=\lfloor \dfrac n x \rfloor \lfloor \dfrac m x \rfloor</script><p>那么此时我们显然就可以运用反演了：</p>
<script type="math/tex; mode=display">
g(x)=\sum_{x\mid d} f(d)=\lfloor \dfrac n x \rfloor \lfloor \dfrac m x \rfloor\iff f(x)=\sum_{d\mid x} \mu(d)g(\dfrac x d)</script><hr>
<h4 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h4><h5 id="P3455-POI2007-ZAP-Queries"><a href="#P3455-POI2007-ZAP-Queries" class="headerlink" title="P3455 [POI2007]ZAP-Queries"></a><a href="https://www.luogu.com.cn/problem/P3455">P3455 [POI2007]ZAP-Queries</a></h5><p>题目描述：</p>
<p>求解：</p>
<script type="math/tex; mode=display">
\sum _{i=1}^a \sum _{j=1 }^b [\gcd (i,j)==k]</script><hr>
<p>那么我们设 </p>
<script type="math/tex; mode=display">
f(k)=\sum_{i=1}^a \sum_{j=1}^b [\gcd(i,j)=k]</script><script type="math/tex; mode=display">
F(n)=\sum_{n\mid k} f(k)=\lfloor \dfrac a n  \rfloor \lfloor \dfrac b n \rfloor</script><p>由反演可知：</p>
<script type="math/tex; mode=display">
f(n)=\sum_{n\mid k} \mu(\lfloor \dfrac k n \rfloor)F(k)</script><p>我们要求的答案应该是 $f(k)$</p>
<p>那么我们有：</p>
<script type="math/tex; mode=display">
f(k)=\sum _{k\mid d} \mu(\lfloor \dfrac d k \rfloor)F(d)</script><p>把 $F(d)$ 化简可得：</p>
<script type="math/tex; mode=display">
f(k)=\sum _{k\mid d} \mu(\lfloor \dfrac d k \rfloor)\lfloor \dfrac a d  \rfloor \lfloor \dfrac b d \rfloor</script><p>设 $\lfloor \dfrac d k\rfloor$ 为 $t$</p>
<p>则 $d=kt$ ，所以：</p>
<script type="math/tex; mode=display">
f(k)=\sum _{t=1} ^{\min(a,b)} \mu (t)\lfloor \dfrac a {kt}  \rfloor \lfloor \dfrac b {kt} \rfloor</script><p>我们根据这个就可以利用整数分块来求了</p>
<hr>
<h5 id="P2257-YY的GCD"><a href="#P2257-YY的GCD" class="headerlink" title="P2257 YY的GCD"></a><a href="https://www.luogu.com.cn/problem/P2257">P2257 YY的GCD</a></h5><p>题目描述：</p>
<script type="math/tex; mode=display">
\sum _{i=1} ^n \sum_{j=1}^m [\gcd (i,j)==k]~~{k\in prime}</script><hr>
<p>首先我们还是先化简原式：</p>
<p>设：</p>
<script type="math/tex; mode=display">
f(x)=\sum _{i=1} ^n \sum_{j=1}^m [\gcd (i,j)==x]\\
F(x)=\sum _{x\mid d} f(d)=\lfloor \dfrac n x \rfloor \lfloor \dfrac m x \rfloor\\
f(x)=\sum_{x\mid d} \mu(\lfloor\dfrac d x \rfloor) F(d)</script><p>然后我们把题目写成一般形式就是：</p>
<script type="math/tex; mode=display">
\sum_{p\in prime}\sum _{i=1}^n \sum _{j=1}^m[\gcd(i,j)==p]</script><p>我们要求的答案就是：</p>
<script type="math/tex; mode=display">
\sum_{p\in prime}f(p)</script><p>我们利用莫比乌斯反演，即上面的第三个式子就有：</p>
<script type="math/tex; mode=display">
\sum_{p\in prime} f(p) =\sum_{p\in prime} \sum_{p\mid d} \mu(\lfloor\dfrac d p \rfloor) F(d)</script><p>我们设 $\lfloor \dfrac d p\rfloor  = t$ 则 $d=pt$ </p>
<script type="math/tex; mode=display">
\sum_{p\in prime} f(p) =\sum_{p\in prime} \sum_{t=1}^{\min(\lfloor \frac n {p} \rfloor,\lfloor \frac m {p} \rfloor)} \mu(t) F(pt) =\sum_{p\in prime} \sum_{t=1}^{\min(\lfloor \frac n {p} \rfloor,\lfloor \frac m {p} \rfloor)} \mu(t) \lfloor \dfrac n {pt} \rfloor \lfloor \dfrac m {pt} \rfloor</script><p>现在我们是枚举每一个 $p$ 的倍数进行处理，因此我们也可以改成枚举每一个数的质因数</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{\min (n,m)} \sum _{t\in prime ~\cap~ t\mid i} \mu(\dfrac i t)\lfloor \dfrac{m}{i} \rfloor \lfloor \dfrac{n}{i}\rfloor</script><p>把 $\lfloor \dfrac m i \rfloor \lfloor \dfrac n i\rfloor $ 扔出来就有：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{\min (n,m)} \lfloor \dfrac{m}{i} \rfloor \lfloor \dfrac{n}{i}\rfloor\sum _{t\in prime ~\cap~ t\mid i} \mu(\dfrac i t)</script><p>我们观察发现：后面的 $\sum \mu (\dfrac i t)$ 可以直接处理掉</p>
<p>当然，在我们也可以根据一些代数意义化简，当我们化简到这一步的时候：</p>
<script type="math/tex; mode=display">
\sum_{p\in prime} \sum_{p\mid d} \mu(\lfloor\dfrac d p \rfloor) F(d)</script><p>翻译成人话就是：对于每一个质数，我枚举它的倍数，使得 $ans$ 加上 $\mu(\lfloor\dfrac d p \rfloor) F(d)$</p>
<p>那么我们完全可以换一种思路，枚举每一个数，加上它分解质因数后的每一个因数即可，此时对于我的 $\mu$ 来说，就是 $i$ 是 $p$ 的多少倍，$F$ 就是当前的 $i$ 是几</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{\min(n,m)} \sum _{p\in prime \cap p\mid i} \mu(\lfloor \dfrac i p \rfloor)F(i)</script><p>然后拆开 $F(i)$ 就行了</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{\min (n,m)} \sum _{p\in prime ~\cap~ p\mid i} \mu(\lfloor \dfrac i p \rfloor)\lfloor \dfrac{m}{i} \rfloor \lfloor \dfrac{n}{i}\rfloor
\\ \sum_{i=1}^{\min (n,m)} \lfloor \dfrac{m}{i} \rfloor \lfloor \dfrac{n}{i}\rfloor\sum _{p\in prime ~\cap~ p\mid i} \mu(\lfloor \dfrac i p \rfloor)</script><p>其实和上面的化简是长的一样的，只是换一种理解方式，可以减少很多不必要的步骤。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BlackPink is the Revolution</span></span><br><span class="line"><span class="comment">light up the sky</span></span><br><span class="line"><span class="comment">Blackpink in your area</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e7</span>+<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="number">3.141592653589793</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">namespace</span> scan&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">        x=<span class="number">0</span>; <span class="keyword">char</span> c=<span class="built_in">getchar</span>(); <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c=<span class="built_in">getchar</span>()) f |= c==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c=<span class="built_in">getchar</span>()) x = x*<span class="number">10</span>+(c^<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">if</span>(f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T &amp;x,<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">short</span> st[<span class="number">30</span>],tp;</span><br><span class="line">        <span class="keyword">do</span> st[++tp] = x%<span class="number">10</span>, x/=<span class="number">10</span>; <span class="keyword">while</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(tp) <span class="built_in">putchar</span>(st[tp--] | <span class="number">48</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> scan;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt;</span><br><span class="line"><span class="keyword">int</span> prime[N],mu[N],g[N];</span><br><span class="line"><span class="keyword">int</span> sum[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!st[i]) prime[++cnt]=i,mu[i]=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;prime[j]*i&lt;n;j++)&#123;</span><br><span class="line">			st[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">			mu[i*prime[j]]=-mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*prime[j]&lt;=n;i++) g[i*prime[j]]+=mu[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i]=sum[i<span class="number">-1</span>]+g[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> T,ans;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">get_prime</span>(N<span class="number">-100</span>);</span><br><span class="line">	<span class="comment">// for(int i=1;i&lt;=cnt;i++) cout&lt;&lt;prime[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">read</span>(n),<span class="built_in">read</span>(m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(n/l==<span class="number">0</span> || m/l==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">			r=<span class="built_in">min</span>(n/(n/l),(m/(m/l)));</span><br><span class="line">			ans+=(sum[r]-sum[l<span class="number">-1</span>])*(m/l)*(n/l);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="P3327-SDOI2015-约数个数和"><a href="#P3327-SDOI2015-约数个数和" class="headerlink" title="P3327 [SDOI2015]约数个数和"></a><a href="https://www.luogu.com.cn/problem/P3327">P3327 [SDOI2015]约数个数和</a></h5><p>题目描述：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n \sum _{j=1} ^m d(i\times j)</script><hr>
<p>首先有一个引理：</p>
<script type="math/tex; mode=display">
d(i\times j) =\sum _{a \mid i} \sum _{b\mid j} [\gcd(a,b)==1]</script><p>找了半天也没找到证明，貌似只有一个，还是我没看懂的</p>
<hr>
<p>所以我们就直接搞吧</p>
<script type="math/tex; mode=display">
\begin{align*}
\sum_{i=1}^n \sum _{j=1} ^m d(i\times j)&=\sum_{i=1}^n \sum _{j=1}^m\sum _{a \mid i} \sum _{b\mid j} [\gcd(a,b)==1]\\
&=\sum _{a=1} \sum_{b=1} \lfloor \dfrac n a \rfloor \lfloor \dfrac m b \rfloor [\gcd(a,b)==1]
\end{align*}</script><p>于是我们直接设</p>
<script type="math/tex; mode=display">
f(x)=\sum _{i=1} \sum_{j=1} \lfloor \dfrac n i \rfloor \lfloor \dfrac m j \rfloor [\gcd(i,j)==1]\\
F(x)=\sum_{x\mid d}f(d)</script><p>反演一下：</p>
<script type="math/tex; mode=display">
f(x)=\sum_{x\mid d} \mu(\lfloor\dfrac d x \rfloor) F(d)</script><p>于是有：</p>
<script type="math/tex; mode=display">
\begin{align*}
F(x)&=\sum _{i=1}^n \sum_{j=1}^m \lfloor \dfrac n i \rfloor \lfloor \dfrac m j \rfloor [ x|\gcd(i,j)]\\
&=\sum_{i=1}^{\frac n x} \sum_{j=1}^{\frac m x}\lfloor \dfrac n {xi}\rfloor \lfloor \dfrac {m}{xj}\rfloor
\end{align*}</script><p>我们的答案是 $f(1)$</p>
<p>所以</p>
<script type="math/tex; mode=display">
f(1)=\sum _{d=1}^n \mu (d)F(d)\\
f(1)=\sum _{d=1}^n \mu (d)\sum_{i=1}^{\frac n d} \sum_{j=1}^{\frac m d}\lfloor \dfrac n {di}\rfloor \lfloor \dfrac {m}{dj}\rfloor</script><p>我们发现前面的 $\mu$ 可以前缀和预处理掉显然好处理，后面的我们可以考虑想想办法</p>
<p>我们尝试先把后面的 $d$ 扔出去</p>
<script type="math/tex; mode=display">
f(1)=\sum _{d=1}^n \mu (d)\sum_{i=1}^{\frac n d} \sum_{j=1}^{\frac m d}\lfloor \dfrac n {di}\rfloor \lfloor \dfrac {m}{dj}\rfloor</script><p>我们这时候发现 $\lfloor \dfrac n {di} \rfloor$ 与 $j$ 无关，可以放到前面：</p>
<script type="math/tex; mode=display">
f(1)=\sum _{d=1}^n \mu (d)\sum_{i=1}^{\frac n d} \lfloor \dfrac n {di}\rfloor \sum_{j=1}^{\frac m d} \lfloor \dfrac {m}{dj}\rfloor</script><p>我们发现后面的两个 $\Sigma$ 互不影响 </p>
<p>这样，我们就可以分别处理了，时间复杂度 $O(T\sqrt n +n\sqrt n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BlackPink is the Revolution</span></span><br><span class="line"><span class="comment">light up the sky</span></span><br><span class="line"><span class="comment">Blackpink in your area</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="number">3.141592653589793</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> scan&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">        x=<span class="number">0</span>; <span class="keyword">char</span> c=<span class="built_in">getchar</span>(); <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c=<span class="built_in">getchar</span>()) f |= c==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c=<span class="built_in">getchar</span>()) x = x*<span class="number">10</span>+(c^<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">if</span>(f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T x,<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">short</span> st[<span class="number">30</span>],tp;</span><br><span class="line">        <span class="keyword">do</span> st[++tp] = x%<span class="number">10</span>, x/=<span class="number">10</span>; <span class="keyword">while</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(tp) <span class="built_in">putchar</span>(st[tp--] | <span class="number">48</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> scan;</span><br><span class="line"><span class="keyword">int</span> n,m,T;</span><br><span class="line"><span class="keyword">int</span> mu[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N],h[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_mu</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;=n;j+=i) mu[j]-=mu[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i]=sum[i<span class="number">-1</span>]+mu[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">1</span>;d&lt;=n;d++)&#123;</span><br><span class="line">		ll res=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=d;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">			r=d/(d/l);</span><br><span class="line">			res+=<span class="number">1ll</span>*(r-l+<span class="number">1</span>)*<span class="number">1ll</span>*(d/l);</span><br><span class="line">		&#125;</span><br><span class="line">		h[d]=res;</span><br><span class="line">	&#125;<span class="comment">//n sqrt n</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">get_mu</span>(N<span class="number">-5</span>);</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=100;i++) cout&lt;&lt;h[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    	<span class="built_in">read</span>(n),<span class="built_in">read</span>(m);</span><br><span class="line">    	<span class="keyword">if</span>(n&gt;m) <span class="built_in">swap</span>(n,m);</span><br><span class="line">    	ll ans=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    		r=<span class="built_in">min</span>(n/(n/l),m/(m/l));</span><br><span class="line">    		<span class="comment">// cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;&quot; &quot;;</span></span><br><span class="line">    		ans+=<span class="number">1ll</span>*(sum[r]-sum[l<span class="number">-1</span>])*<span class="number">1ll</span>*h[n/l]*h[m/l];</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="built_in">write</span>(ans,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="P1829-国家集训队-Crash的数字表格-JZPTAB"><a href="#P1829-国家集训队-Crash的数字表格-JZPTAB" class="headerlink" title="P1829 [国家集训队]Crash的数字表格 / JZPTAB"></a><a href="https://www.luogu.com.cn/problem/P1829">P1829 [国家集训队]Crash的数字表格 / JZPTAB</a></h5><p>题目描述：</p>
<script type="math/tex; mode=display">
\sum _{i=1}^n \sum _{j=1} ^m \mathrm{lcm}(i,j)</script><p>数据范围：$1\le n,m\le 10^7$</p>
<hr>
<p>首先我们根据<del>小学知识</del>可以发现</p>
<p>$\gcd(i,j)*\mathrm{lcm}(i,j)=i\times j$</p>
<p>所以我们的题意就变成了</p>
<script type="math/tex; mode=display">
\sum _{i=1}^n \sum _{j=1} ^m \dfrac {ij}{\gcd(i,j)}</script><p>那么就好做多了，我们可以直接枚举 $\gcd $ 并把它放到最前面</p>
<script type="math/tex; mode=display">
\sum_{d=1}^{\min(n,m)}\sum_{i=1}^ n \sum_{j=1}^m [gcd (i,j)==d]\dfrac {ij} {d}\\</script><p>我们枚举 $d$ 的倍数可以发现：</p>
<script type="math/tex; mode=display">
\sum_{d=1}^{\min(n,m)}\sum_{i=1}^{\frac n d}\sum_{j=1}^{\frac m d} i j d [\gcd(i,j)=1]\\
\sum_{d=1}^{\min(n,m)}d\sum_{i=1}^{\frac n d}\sum_{j=1}^{\frac m d} i j[\gcd(i,j)=1]\\
\sum_{d=1}^{\min(n,m)}d\sum_{i=1}^{\frac n d}i\sum_{j=1}^{\frac m d} j\sum_{k\mid \gcd(i,j)} \mu(k)\\</script><p>我们把 $\mu (k)$  的枚举项拿出来，那么式子就变成了（为了方便，就不写 $\min$ 了）</p>
<script type="math/tex; mode=display">
\sum_{d=1} ^n d\sum_{k=1}^n\mu(k) \sum_{k\mid i}^{\frac n d} i\sum_{k\mid j}^{\frac m d}j\\</script><p>我们这个式子的最后一个 $\sum$ 的意思是，从 $1\sim \dfrac n d$ 中选取 $k$ 的倍数相加，那么我们可以直接写成：</p>
<script type="math/tex; mode=display">
\sum_{d=1} ^n d\sum_{k=1}^n\mu(k) \sum_{i=1}^{\frac n {dk}} ik\sum_{j=1}^{\frac m {dk}}jk\\
\sum_{d=1} ^n d\sum_{k=1}^n k^2 \mu(k) \sum_{i=1}^{\frac n {dk}} i\sum_{j=1}^{\frac m {dk}}j\\</script><p> 最后两个 $\sum$ 很明显示两个等差数列，我们<del>兴奋地</del>写成等差数列形式</p>
<script type="math/tex; mode=display">
\sum_{d=1} ^n d\sum_{k=1}^nk^2\mu(k)\dfrac {\lfloor \frac n {dk} \rfloor(\lfloor \frac n {dk} \rfloor+1)} {2}\dfrac {\lfloor \frac m {dk} \rfloor(\lfloor \frac m {dk} \rfloor+1)} 2</script><p>然后我们先枚举后面巨大的等差数列求和就有：</p>
<script type="math/tex; mode=display">
\sum_{d=1} ^n\sum_{k=1}^ndk^2\mu(k)\dfrac {\lfloor \frac n {dk} \rfloor(\lfloor \frac n {dk} \rfloor+1)} {2}\dfrac {\lfloor \frac m {dk} \rfloor(\lfloor \frac m {dk} \rfloor+1)} 2</script><p>那么后面就可以分别预处理加整除分块来做了！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BlackPink is the Revolution</span></span><br><span class="line"><span class="comment">light up the sky</span></span><br><span class="line"><span class="comment">Blackpink in your area</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e7</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">20101009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="number">3.141592653589793</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> scan&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">        x=<span class="number">0</span>; <span class="keyword">char</span> c=<span class="built_in">getchar</span>(); <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c=<span class="built_in">getchar</span>()) f |= c==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c=<span class="built_in">getchar</span>()) x = x*<span class="number">10</span>+(c^<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">if</span>(f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T x,<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">short</span> st[<span class="number">30</span>],tp;</span><br><span class="line">        <span class="keyword">do</span> st[++tp] = x%<span class="number">10</span>, x/=<span class="number">10</span>; <span class="keyword">while</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(tp) <span class="built_in">putchar</span>(st[tp--] | <span class="number">48</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> scan;</span><br><span class="line"><span class="keyword">int</span> mu[N],prime[N],cnt;</span><br><span class="line">ll sum[N],h[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qm</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a%mod+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a+b)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!st[i]) prime[++cnt]=i,mu[i]=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;prime[j]*i&lt;n;j++)&#123;</span><br><span class="line">			st[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">			mu[i*prime[j]]=-mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) mu[i]=<span class="built_in">qm</span>(<span class="number">1ll</span>*mu[i]*i*i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i]=<span class="built_in">add</span>(sum[i<span class="number">-1</span>],mu[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">qm</span>(<span class="number">1ll</span>*<span class="built_in">qm</span>(<span class="number">1ll</span>*x*(x+<span class="number">1</span>)/<span class="number">2</span>)*<span class="built_in">qm</span>(<span class="number">1ll</span>*y*(y+<span class="number">1</span>)/<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	ll res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=x;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">		r=<span class="built_in">min</span>(x/(x/l),y/(y/l));</span><br><span class="line">		res=<span class="built_in">add</span>(res, <span class="built_in">qm</span>(<span class="number">1ll</span>*(sum[r]-sum[l<span class="number">-1</span>])*(<span class="built_in">get_sum</span>(x/l,y/l))));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">get_prime</span>(N);</span><br><span class="line">    <span class="built_in">read</span>(n),<span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m) <span class="built_in">swap</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    	r=<span class="built_in">min</span>(n/(n/l), m/(m/l));</span><br><span class="line">    	res=<span class="built_in">add</span>(res, <span class="built_in">qm</span>(<span class="number">1ll</span>*(r-l+<span class="number">1</span>)*(l+r)/<span class="number">2</span>%mod*<span class="built_in">g</span>(n/l,m/l)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(<span class="built_in">qm</span>(res),<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="AT5200-AGC038C-LCMs"><a href="#AT5200-AGC038C-LCMs" class="headerlink" title="AT5200 [AGC038C] LCMs"></a><a href="https://www.luogu.com.cn/problem/AT5200">AT5200 [AGC038C] LCMs</a></h5><p>题目描述：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n \sum_{j=i+1}^m \mathrm{lcm}(A_i,A_j)</script><hr>
<p>首先，利用容斥原理我们会发现，上面的这个玩意长成这样肯定不想要的</p>
<p>于是我们把它们放到一个按 $A_1 ~A_2~A_3~A_4~A_5~A_6\dots A_n$ 上</p>
<p><img src="https://s4.ax1x.com/2021/12/05/oDzu9K.jpg" alt=""></p>
<p>很容易发现，我们要求的就是右边的那个大三角，</p>
<p>但是我们发现肯定是左边的更好处理，所以我们可以开始行动了</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n \sum_{j=i+1}^m \mathrm{lcm}(A_i,A_j)=\dfrac {\sum_{i=1}^n \sum_{j=1}^m \mathrm{lcm}(i,j)-\sum_{i=1}^n A_i} 2</script><p>那我们就只把那一块拿出来观察：</p>
<script type="math/tex; mode=display">
\begin{align*}
\sum_{i=1}^n \sum_{j=1}^m \mathrm{lcm}(A_i,A_j)&=\sum_{i=1}^n \sum_{j=1}^m \dfrac {A_iA_j} {\gcd(A_i,A_j)}\\
&=\sum_{d=1}^{\max{A}}\dfrac 1 d\sum_{i=1}^n\sum_{j=1}^n [\gcd(A_i,A_j)==d]A_iA_j\\
&=\sum_{d=1}^{\max{A}}\dfrac 1 d\sum_{i=1}^n\sum_{j=1}^n A_iA_j[d\mid A_i][d\mid A_j][\gcd(\dfrac {A_i} {d} ,\dfrac {A_j} {d})==1]\\
\end{align*}</script><p>然后我们就能进行反演了：</p>
<script type="math/tex; mode=display">
\sum_{d=1}^{\max{A}}\dfrac 1 d\sum_{i=1}^n\sum_{j=1}^n A_iA_j[d\mid A_i][d\mid A_j][\gcd(\dfrac {A_i} {d} ,\dfrac {A_j} {d})==1]\\
\sum_{d=1}^{\max{A}}\dfrac 1 d\sum_{i=1}^n\sum_{j=1}^n A_iA_j[d\mid A_i][d\mid A_j]\sum_{k\mid \gcd(\frac {A_i} {d} ,\frac {A_j} {d})} \mu(k)\\
\sum_{d=1}^{\max{A}}\sum_{k=1}^{\frac {\max A} d}\dfrac {\mu(k)} d\sum_{i=1}^n\sum_{j=1}^n A_iA_j[dk\mid A_i][dk\mid A_j]\\
\sum_{d=1}^{\max{A}}\sum_{k=1}^{\frac {\max A} d}\dfrac {\mu(k)} d(\sum_{i=1}^nA_i[dk\mid A_i])^2\\</script><p>后面的应该可以开个桶来处理了</p>
<p>然后我们直接枚举桶里面的元素即可</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/%E9%93%BE%E8%A1%A8(%E5%8D%95%E5%8A%A0%E5%8F%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h4 id="单链表-多个单链表构成邻接表-：应用：存储图，存储树"><a href="#单链表-多个单链表构成邻接表-：应用：存储图，存储树" class="headerlink" title="单链表   多个单链表构成邻接表 ：应用：存储图，存储树"></a>单链表   多个单链表构成邻接表 ：应用：存储图，存储树</h4><h4 id="双链表-应用：优化某些题"><a href="#双链表-应用：优化某些题" class="headerlink" title="双链表 应用：优化某些题"></a>双链表 应用：优化某些题</h4><h5 id="1-单链表："><a href="#1-单链表：" class="headerlink" title="1.单链表："></a>1.单链表：</h5><p>用数组模拟：<br>1.定义每个节点的val</p>
<p>e[n]定义当前点<br>ne[n] 定义下一个节点的位置</p>
<p>如下图所示</p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20210805185832865.png" alt="image-20210805185832865"></p>
<p>空节点下标用-1表示</p>
<p>单链表：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="comment">//head 表示头结点的下标</span></span><br><span class="line"><span class="comment">//e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">//ne[i] 表示节点i的next指针是多少</span></span><br><span class="line"><span class="comment">//idx存储当前已经用到了哪个点</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head=<span class="number">-1</span>;</span><br><span class="line">    idx=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_head</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    ne[idx]=head;</span><br><span class="line">    head=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将x插到头节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    ne[idx]=ne[k];</span><br><span class="line">    ne[k]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将x插到k的后面</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k]=ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        <span class="keyword">int</span> k,x;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;H&#x27;</span>) cin&gt;&gt;x,<span class="built_in">add_to_head</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span>(op==<span class="string">&#x27;D&#x27;</span>) cin&gt;&gt;k,<span class="built_in">remove</span>(k);</span><br><span class="line">        <span class="keyword">else</span> cin&gt;&gt;k&gt;&gt;x,<span class="built_in">add</span>(k,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head&amp;&amp;i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">        cout&lt;&lt;e[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-双链表"><a href="#2-双链表" class="headerlink" title="2.双链表"></a>2.双链表</h5><p>每一个点有两个指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> l[n],r[n],e[n];<span class="comment">//l指每个点左边的点是谁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//l,r赋值为0表示左端点，1表示右端点</span></span><br><span class="line">	r[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	l[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    idx=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在下标是k的点的右边，插入x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    r[idx]=r[k];</span><br><span class="line">    l[idx]=k;</span><br><span class="line">    r[k]=idx;</span><br><span class="line">    l[r[k]]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    r[l[k]]=r[k];</span><br><span class="line">    l[r[k]]=l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
